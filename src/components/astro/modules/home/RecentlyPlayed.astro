---
export const prerender = false; // Disable static generation
export const partial = false;   // Ensure full server-side rendering

interface Track {
  name: string;
  artist: string;
  url: string;
  image: string;
}

// Cache the results for 5 minutes to avoid hitting Last.fm API too frequently
let cachedTracks: Track[] | null = null;
let lastFetch = 0;
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes in milliseconds

async function getRecentTracks(): Promise<Track[]> {
  // Return cached results if available and fresh
  if (cachedTracks && (Date.now() - lastFetch < CACHE_DURATION)) {
    return cachedTracks;
  }

  try {
    const LASTFM_API_KEY = import.meta.env.LASTFM_API_KEY;
    const LASTFM_USERNAME = 'waleedhkhan';

    if (!LASTFM_API_KEY) {
      throw new Error('LastFM API key is not configured');
    }

    const response = await fetch(
      `https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user=${LASTFM_USERNAME}&api_key=${LASTFM_API_KEY}&format=json&limit=6`,
      {
        headers: {
          'Accept': 'application/json',
        },
        // Add caching headers
        cache: 'no-cache'
      }
    );

    if (!response.ok) {
      throw new Error(`API request failed: ${await response.text()}`);
    }

    const data = await response.json();
    
    if (!data?.recenttracks?.track) {
      throw new Error('Unexpected API response structure');
    }

    const tracks = data.recenttracks.track.map((track: any) => ({
      name: track.name || 'Unknown Track',
      artist: track.artist?.['#text'] || 'Unknown Artist',
      url: track.url || '#',
      image: track.image?.[2]?.['#text'] || 'https://via.placeholder.com/64'
    }));

    // Update cache
    cachedTracks = tracks;
    lastFetch = Date.now();

    return tracks;
  } catch (error) {
    console.error('Error fetching LastFM data:', error);
    return cachedTracks || []; // Return cached data on error, or empty array if no cache
  }
}

const initialRecentTracks = await getRecentTracks();
---

<div id="recently-played" class="space-y-4" data-tracks={JSON.stringify(initialRecentTracks)}>
  <div>
    <h4 class=":uno: text-sm font-medium text-zinc-900 dark:text-zinc-100">Played Music</h4>
  </div>

  <div id="tracks-container">
    {initialRecentTracks.length > 0 ? (
      <ul class=":uno: grid grid-cols-2 gap-4">
        {initialRecentTracks.map((track) => (
          <li>
            <a
              class=":uno: group flex items-center gap-3 rounded-lg p-2 transition-colors hover:bg-zinc-100 dark:hover:bg-zinc-800"
              href={track.url}
              target="_blank"
              rel="noopener noreferrer"
            >
              <img
                src={track.image}
                alt={`${track.name} album art`}
                class=":uno: h-12 w-12 rounded-md"
              />
              <div class=":uno: flex-1 overflow-hidden">
                <p class=":uno: truncate text-sm font-medium text-zinc-900 dark:text-zinc-100">
                  {track.name}
                </p>
                <p class=":uno: truncate text-xs text-zinc-500 dark:text-zinc-400">
                  {track.artist}
                </p>
              </div>
            </a>
          </li>
        ))}
      </ul>
    ) : (
      <p class=":uno: text-sm text-zinc-500 dark:text-zinc-400">
        No recently played tracks available
      </p>
    )}
  </div>
</div>

<script is:inline define:vars={{ initialTracks: initialRecentTracks }}>
  // Make sure this script runs as soon as it's loaded, with direct access to initialTracks
  (function() {
    // Function to fetch recently played tracks from API
    async function fetchRecentTracks() {
      try {
        const response = await fetch('/api/recently-played');
        if (!response.ok) {
          throw new Error('Failed to fetch tracks');
        }
        return await response.json();
      } catch (error) {
        console.error('Error fetching tracks:', error);
        return [];
      }
    }

    // Function to render tracks to the container
    function renderTracks(tracks) {
      const container = document.getElementById('tracks-container');
      if (!container) return; // Exit if container not found
      
      if (!tracks || !tracks.length) {
        container.innerHTML = `<p class="text-sm text-zinc-500 dark:text-zinc-400">No recently played tracks available</p>`;
        return;
      }

      const tracksList = `
        <ul class="grid grid-cols-2 gap-4">
          ${tracks.map(track => `
            <li>
              <a
                class="group flex items-center gap-3 rounded-lg p-2 transition-colors hover:bg-zinc-100 dark:hover:bg-zinc-800"
                href="${track.url}"
                target="_blank"
                rel="noopener noreferrer"
              >
                <img
                  src="${track.image}"
                  alt="${track.name} album art"
                  class="h-12 w-12 rounded-md"
                />
                <div class="flex-1 overflow-hidden">
                  <p class="truncate text-sm font-medium text-zinc-900 dark:text-zinc-100">
                    ${track.name}
                  </p>
                  <p class="truncate text-xs text-zinc-500 dark:text-zinc-400">
                    ${track.artist}
                  </p>
                </div>
              </a>
            </li>
          `).join('')}
        </ul>
      `;
      
      container.innerHTML = tracksList;
    }

    // Set up the auto-refresh immediately
    let autoRefreshTimer = null;
    
    function startAutoRefresh() {
      // Clear any existing timer first
      if (autoRefreshTimer) {
        clearInterval(autoRefreshTimer);
      }
      
      // Define the refresh function
      const refreshData = async () => {
        console.log('Refreshing recently played tracks...');
        try {
          const tracks = await fetchRecentTracks();
          if (tracks && tracks.length > 0) {
            renderTracks(tracks);
            console.log('Tracks refreshed successfully');
          }
        } catch (err) {
          console.error('Error during refresh:', err);
        }
      };
      
      // Start the periodic refresh (every minute)
      autoRefreshTimer = setInterval(refreshData, 60000);
      
      // Also trigger an immediate refresh
      refreshData();
    }
    
    // Start the auto-refresh when the page is visible
    function handleVisibilityChange() {
      if (document.visibilityState === 'visible') {
        startAutoRefresh();
      } else {
        if (autoRefreshTimer) {
          clearInterval(autoRefreshTimer);
          autoRefreshTimer = null;
        }
      }
    }
    
    // Set up the visibility change handler
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    // Start auto-refresh immediately if page is visible
    if (document.visibilityState === 'visible') {
      startAutoRefresh();
    }
    
    // Clean up when the page is unloaded
    window.addEventListener('beforeunload', () => {
      if (autoRefreshTimer) {
        clearInterval(autoRefreshTimer);
      }
    });
  })();
</script>
