---
export const prerender = false; // Disable static generation
export const partial = false;   // Ensure full server-side rendering

interface Track {
  name: string;
  artist: string;
  url: string;
  image: string;
}

// Cache the results for 5 minutes to avoid hitting Last.fm API too frequently
let cachedTracks: Track[] | null = null;
let lastFetch = 0;
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes in milliseconds

async function getRecentTracks(): Promise<Track[]> {
  // Return cached results if available and fresh
  if (cachedTracks && (Date.now() - lastFetch < CACHE_DURATION)) {
    return cachedTracks;
  }

  try {
    const LASTFM_API_KEY = import.meta.env.LASTFM_API_KEY;
    const LASTFM_USERNAME = 'waleedhkhan';

    if (!LASTFM_API_KEY) {
      throw new Error('LastFM API key is not configured');
    }

    const response = await fetch(
      `https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user=${LASTFM_USERNAME}&api_key=${LASTFM_API_KEY}&format=json&limit=6`,
      {
        headers: {
          'Accept': 'application/json',
        },
        // Add caching headers
        cache: 'no-cache'
      }
    );

    if (!response.ok) {
      throw new Error(`API request failed: ${await response.text()}`);
    }

    const data = await response.json();
    
    if (!data?.recenttracks?.track) {
      throw new Error('Unexpected API response structure');
    }

    const tracks = data.recenttracks.track.map((track: any) => ({
      name: track.name || 'Unknown Track',
      artist: track.artist?.['#text'] || 'Unknown Artist',
      url: track.url || '#',
      image: track.image?.[2]?.['#text'] || 'https://via.placeholder.com/64'
    }));

    // Update cache
    cachedTracks = tracks;
    lastFetch = Date.now();

    return tracks;
  } catch (error) {
    console.error('Error fetching LastFM data:', error);
    return cachedTracks || []; // Return cached data on error, or empty array if no cache
  }
}

const initialRecentTracks = await getRecentTracks();
---
  <div id="tracks-container">
    {initialRecentTracks.length > 0 ? (
      <ul class=":uno: grid grid-cols-2 gap-4">
        {initialRecentTracks.map((track) => (
          <li>
            <a
              class=":uno: group flex items-center gap-3 rounded-lg p-2 transition-colors hover:bg-zinc-100 dark:hover:bg-zinc-800"
              href={track.url}
              target="_blank"
              rel="noopener noreferrer"
            >
              <img
                src={track.image}
                alt={`${track.name} album art`}
                class=":uno: h-12 w-12 rounded-md"
              />
              <div class=":uno: flex-1 overflow-hidden">
                <p class=":uno: truncate text-sm font-medium text-zinc-900 dark:text-zinc-100">
                  {track.name}
                </p>
                <p class=":uno: truncate text-xs text-zinc-500 dark:text-zinc-400">
                  {track.artist}
                </p>
              </div>
            </a>
          </li>
        ))}
      </ul>
    ) : (
      <p class=":uno: text-sm text-zinc-500 dark:text-zinc-400">
        No recently played tracks available
      </p>
    )}
  </div>
</div>


<div id="recently-played" class="space-y-4" data-tracks={JSON.stringify(initialRecentTracks)}>
  <div class="flex justify-between items-center mb-2">
    <h2 class=":uno: text-sm font-medium text-zinc-900 dark:text-zinc-100"></h2>
    <button id="refresh-tracks" class=":uno: text-xs text-zinc-500 dark:text-zinc-400 hover:text-zinc-900 dark:hover:text-zinc-100">
      <svg xmlns="http://www.w3.org/2000/svg" class=":uno: h-4 w-4 inline" viewBox="0 0 20 20" fill="currentColor">
        <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" />
      </svg>
    </button>
  </div>


<script>
  // Function to fetch recently played tracks from API
  async function fetchRecentTracks() {
    try {
      const response = await fetch('/api/recently-played');
      if (!response.ok) {
        throw new Error('Failed to fetch tracks');
      }
      return await response.json();
    } catch (error) {
      console.error('Error fetching tracks:', error);
      return [];
    }
  }

  // Function to render tracks to the container
  function renderTracks(tracks) {
    const container = document.getElementById('tracks-container');
    if (!tracks || !tracks.length) {
      container.innerHTML = `<p class="text-sm text-zinc-500 dark:text-zinc-400">No recently played tracks available</p>`;
      return;
    }

    const tracksList = `
      <ul class="grid grid-cols-2 gap-4">
        ${tracks.map(track => `
          <li>
            <a
              class="group flex items-center gap-3 rounded-lg p-2 transition-colors hover:bg-zinc-100 dark:hover:bg-zinc-800"
              href="${track.url}"
              target="_blank"
              rel="noopener noreferrer"
            >
              <img
                src="${track.image}"
                alt="${track.name} album art"
                class="h-12 w-12 rounded-md"
              />
              <div class="flex-1 overflow-hidden">
                <p class="truncate text-sm font-medium text-zinc-900 dark:text-zinc-100">
                  ${track.name}
                </p>
                <p class="truncate text-xs text-zinc-500 dark:text-zinc-400">
                  ${track.artist}
                </p>
              </div>
            </a>
          </li>
        `).join('')}
      </ul>
    `;
    
    container.innerHTML = tracksList;
  }

  // Set up auto refresh (every minute)
  let autoRefreshInterval;

  function setupAutoRefresh() {
    // Clear any existing intervals
    if (autoRefreshInterval) {
      clearInterval(autoRefreshInterval);
    }

    // Set up new interval
    autoRefreshInterval = setInterval(async () => {
      const tracks = await fetchRecentTracks();
      renderTracks(tracks);
    }, 60000); // 1 minute
  }

  // Initialize with data from the server
  document.addEventListener('DOMContentLoaded', () => {
    const recentlyPlayed = document.getElementById('recently-played');
    const refreshButton = document.getElementById('refresh-tracks');
    
    // Initial tracks from server-side rendering
    const initialTracks = JSON.parse(recentlyPlayed.dataset.tracks || '[]');
    
    // Set up manual refresh button
    refreshButton.addEventListener('click', async () => {
      refreshButton.classList.add('animate-spin');
      const tracks = await fetchRecentTracks();
      renderTracks(tracks);
      refreshButton.classList.remove('animate-spin');
    });
    
    // Set up auto-refresh
    setupAutoRefresh();
  });
</script>
