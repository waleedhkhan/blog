import{AstroError as m}from"astro/errors";import{z as l}from"astro/zod";var u=(e,n)=>{let r=c(e.path);if(e.code==="invalid_union"){let o=new Map;for(let t of e.unionErrors.flatMap(i=>i.errors))if(t.code==="invalid_type"||t.code==="invalid_literal"){let i=c(t.path);o.has(i)?o.get(i).expected.push(t.expected):o.set(i,{code:t.code,received:t.received,expected:[t.expected]})}return{message:[s(r,o.size?"Did not match union:":"Did not match union.")].concat([...o.entries()].filter(([,t])=>t.expected.length===e.unionErrors.length).map(([t,i])=>t===r?`> ${a(i)}`:`> ${s(t,a(i))}`)).join(`
`)}}return e.code==="invalid_literal"||e.code==="invalid_type"?{message:s(r,a({code:e.code,received:e.received,expected:[e.expected]}))}:e.message?{message:s(r,e.message)}:{message:s(r,n.defaultError)}},a=e=>{if(e.received==="undefined")return"Required";let n=new Set(e.expected);switch(e.code){case"invalid_type":return`Expected type \`${d(n)}\`, received ${JSON.stringify(e.received)}`;case"invalid_literal":return`Expected \`${d(n)}\`, received ${JSON.stringify(e.received)}`}},s=(e,n)=>e.length?`**${e}**: ${n}`:n,d=e=>[...e].map((n,r)=>r===0?JSON.stringify(n):` | ${JSON.stringify(n)}`).join(""),c=e=>e.join(".");var v=({name:e,optionsSchema:n,setup:r})=>(...o)=>{let p=(n??l.never().optional()).safeParse(o[0],{errorMap:u});if(!p.success)throw new m(`Invalid options passed to "${e}" integration
`,p.error.issues.map(g=>g.message).join(`
`));let t=p.data,i=r({name:e,options:t});return{name:e,...i}};export{v as defineIntegration};
//# sourceMappingURL=define-integration.js.map