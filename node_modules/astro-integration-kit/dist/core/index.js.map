{"version":3,"sources":["../../src/core/create-resolver.ts","../../src/core/define-integration.ts","../../src/internal/error-map.ts","../../src/core/define-plugin.ts","../../src/core/define-utility.ts","../../src/core/with-plugins.ts","../../src/utilities/add-dts.ts","../../src/utilities/add-virtual-imports.ts","../../src/utilities/has-vite-plugin.ts","../../src/utilities/add-vite-plugin.ts","../../src/utilities/has-integration.ts","../../src/utilities/inject-dev-route.ts","../../src/utilities/watch-directory.ts","../../src/utilities/add-integration.ts"],"sourcesContent":["import { fileURLToPath } from \"node:url\";\nimport { dirname, resolve } from \"pathe\";\n\n/**\n * Allows resolving paths relatively to the integration folder easily. Call it like this:\n *\n * @param {string} _base - The location you want to create relative references from. `import.meta.url` is usually what you'll want.\n *\n * @see https://astro-integration-kit.netlify.app/utilities/create-resolver/\n *\n * @example\n * ```ts\n * const { resolve } = createResolver(import.meta.url);\n * const pluginPath = resolve(\"./plugin.ts\");\n * ```\n *\n * This way, you do not have to add your plugin to your package.json `exports`.\n */\nexport const createResolver = (_base: string) => {\n\tlet base = _base;\n\tif (base.startsWith(\"file://\")) {\n\t\tbase = dirname(fileURLToPath(base));\n\t}\n\n\treturn {\n\t\tresolve: (...path: Array<string>) => resolve(base, ...path),\n\t};\n};\n","import type { AstroIntegration } from \"astro\";\nimport { AstroError } from \"astro/errors\";\nimport { z } from \"astro/zod\";\nimport { errorMap } from \"../internal/error-map.js\";\n\ntype AstroIntegrationSetupFn<Options extends z.ZodTypeAny> = (params: {\n\tname: string;\n\toptions: z.output<Options>;\n}) => Omit<AstroIntegration, \"name\">;\n\n/**\n * A powerful wrapper around the standard Astro Integrations API. It allows integration authors to handle user options and global logic easily.\n *\n * @param {object} params\n * @param {string} params.name - The name of your integration\n * @param {import(\"astro/zod\").AnyZodObject} params.optionsSchema - An optional zod schema to handle your integration options\n * @param {function} params.setup - This will be called from your `astro:config:setup` call with the user options\n *\n * @see https://astro-integration-kit.netlify.app/utilities/define-integration/\n *\n * @example\n * ```ts\n * export default defineIntegration({\n * \t\tname: \"my-integration\",\n * \t\tsetup({ options }) {\n * \t\t\tconsole.log(options.foo); // \"bar\"\n * \t\t}\n * })\n * ```\n */\nexport const defineIntegration = <\n\tTOptionsSchema extends z.ZodTypeAny = z.ZodNever,\n\tTSetup extends\n\t\tAstroIntegrationSetupFn<TOptionsSchema> = AstroIntegrationSetupFn<TOptionsSchema>,\n>({\n\tname,\n\toptionsSchema,\n\tsetup,\n}: {\n\tname: string;\n\toptionsSchema?: TOptionsSchema;\n\tsetup: TSetup;\n}): ((\n\t...args: [z.input<TOptionsSchema>] extends [never]\n\t\t? []\n\t\t: undefined extends z.input<TOptionsSchema>\n\t\t  ? [options?: z.input<TOptionsSchema>]\n\t\t  : [options: z.input<TOptionsSchema>]\n) => AstroIntegration & ReturnType<TSetup>) => {\n\treturn (...args): AstroIntegration & ReturnType<TSetup> => {\n\t\tconst parsedOptions = (optionsSchema ?? z.never().optional()).safeParse(\n\t\t\targs[0],\n\t\t\t{\n\t\t\t\terrorMap,\n\t\t\t},\n\t\t);\n\n\t\tif (!parsedOptions.success) {\n\t\t\tthrow new AstroError(\n\t\t\t\t`Invalid options passed to \"${name}\" integration\\n`,\n\t\t\t\tparsedOptions.error.issues.map((i) => i.message).join(\"\\n\"),\n\t\t\t);\n\t\t}\n\n\t\tconst options = parsedOptions.data as z.output<TOptionsSchema>;\n\n\t\tconst integration = setup({ name, options }) as ReturnType<TSetup>;\n\n\t\treturn {\n\t\t\tname,\n\t\t\t...integration,\n\t\t};\n\t};\n};\n","import type { ZodErrorMap } from \"astro/zod\";\n\n// Source: https://github.com/withastro/astro/blob/d278e66ec6ded7a3ad441e6c3c5f9c265217936f/packages/astro/src/content/error-map.ts\n\ntype TypeOrLiteralErrByPathEntry = {\n\tcode: \"invalid_type\" | \"invalid_literal\";\n\treceived: unknown;\n\texpected: Array<unknown>;\n};\n\nexport const errorMap: ZodErrorMap = (baseError, ctx) => {\n\tconst baseErrorPath = flattenErrorPath(baseError.path);\n\tif (baseError.code === \"invalid_union\") {\n\t\t// Optimization: Combine type and literal errors for keys that are common across ALL union types\n\t\t// Ex. a union between `{ key: z.literal('tutorial') }` and `{ key: z.literal('blog') }` will\n\t\t// raise a single error when `key` does not match:\n\t\t// > Did not match union.\n\t\t// > key: Expected `'tutorial' | 'blog'`, received 'foo'\n\t\tconst typeOrLiteralErrByPath = new Map<\n\t\t\tstring,\n\t\t\tTypeOrLiteralErrByPathEntry\n\t\t>();\n\t\tfor (const unionError of baseError.unionErrors.flatMap((e) => e.errors)) {\n\t\t\tif (\n\t\t\t\tunionError.code === \"invalid_type\" ||\n\t\t\t\tunionError.code === \"invalid_literal\"\n\t\t\t) {\n\t\t\t\tconst flattenedErrorPath = flattenErrorPath(unionError.path);\n\t\t\t\tif (typeOrLiteralErrByPath.has(flattenedErrorPath)) {\n\t\t\t\t\ttypeOrLiteralErrByPath\n\t\t\t\t\t\t.get(flattenedErrorPath)!\n\t\t\t\t\t\t.expected.push(unionError.expected);\n\t\t\t\t} else {\n\t\t\t\t\ttypeOrLiteralErrByPath.set(flattenedErrorPath, {\n\t\t\t\t\t\tcode: unionError.code,\n\t\t\t\t\t\treceived: (unionError as any).received,\n\t\t\t\t\t\texpected: [unionError.expected],\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst messages: string[] = [\n\t\t\tprefix(\n\t\t\t\tbaseErrorPath,\n\t\t\t\ttypeOrLiteralErrByPath.size\n\t\t\t\t\t? \"Did not match union:\"\n\t\t\t\t\t: \"Did not match union.\",\n\t\t\t),\n\t\t];\n\t\treturn {\n\t\t\tmessage: messages\n\t\t\t\t.concat(\n\t\t\t\t\t[...typeOrLiteralErrByPath.entries()]\n\t\t\t\t\t\t// If type or literal error isn't common to ALL union types,\n\t\t\t\t\t\t// filter it out. Can lead to confusing noise.\n\t\t\t\t\t\t.filter(\n\t\t\t\t\t\t\t([, error]) =>\n\t\t\t\t\t\t\t\terror.expected.length === baseError.unionErrors.length,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.map(([key, error]) =>\n\t\t\t\t\t\t\tkey === baseErrorPath\n\t\t\t\t\t\t\t\t? // Avoid printing the key again if it's a base error\n\t\t\t\t\t\t\t\t  `> ${getTypeOrLiteralMsg(error)}`\n\t\t\t\t\t\t\t\t: `> ${prefix(key, getTypeOrLiteralMsg(error))}`,\n\t\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\t.join(\"\\n\"),\n\t\t};\n\t}\n\tif (\n\t\tbaseError.code === \"invalid_literal\" ||\n\t\tbaseError.code === \"invalid_type\"\n\t) {\n\t\treturn {\n\t\t\tmessage: prefix(\n\t\t\t\tbaseErrorPath,\n\t\t\t\tgetTypeOrLiteralMsg({\n\t\t\t\t\tcode: baseError.code,\n\t\t\t\t\treceived: (baseError as any).received,\n\t\t\t\t\texpected: [baseError.expected],\n\t\t\t\t}),\n\t\t\t),\n\t\t};\n\t} else if (baseError.message) {\n\t\treturn { message: prefix(baseErrorPath, baseError.message) };\n\t} else {\n\t\treturn { message: prefix(baseErrorPath, ctx.defaultError) };\n\t}\n};\n\nconst getTypeOrLiteralMsg = (error: TypeOrLiteralErrByPathEntry): string => {\n\tif (error.received === \"undefined\") return \"Required\";\n\tconst expectedDeduped = new Set(error.expected);\n\tswitch (error.code) {\n\t\tcase \"invalid_type\":\n\t\t\treturn `Expected type \\`${unionExpectedVals(\n\t\t\t\texpectedDeduped,\n\t\t\t)}\\`, received ${JSON.stringify(error.received)}`;\n\t\tcase \"invalid_literal\":\n\t\t\treturn `Expected \\`${unionExpectedVals(\n\t\t\t\texpectedDeduped,\n\t\t\t)}\\`, received ${JSON.stringify(error.received)}`;\n\t}\n};\n\nconst prefix = (key: string, msg: string) =>\n\tkey.length ? `**${key}**: ${msg}` : msg;\n\nconst unionExpectedVals = (expectedVals: Set<unknown>) =>\n\t[...expectedVals]\n\t\t.map((expectedVal, idx) => {\n\t\t\tif (idx === 0) return JSON.stringify(expectedVal);\n\t\t\tconst sep = \" | \";\n\t\t\treturn `${sep}${JSON.stringify(expectedVal)}`;\n\t\t})\n\t\t.join(\"\");\n\nconst flattenErrorPath = (errorPath: (string | number)[]) =>\n\terrorPath.join(\".\");\n","import type { Plugin, PluginHooksConstraint } from \"./types.js\";\n\n/**\n * Allows defining a type-safe plugin that can be used in {defineIntegration}.\n *\n * @param {object} plugin\n * @param {string} plugin.name - The name of the plugin, as you want it to be called from the hook\n * @param {string} plugin.hook - The name of the hook where this plugin should be available\n * @param {Function} plugin.implementation - The actual function definition. Refer to docs for usage\n *\n * @see https://astro-integration-kit.netlify.app/utilities/define-plugin/\n *\n * ```ts\n * import { definePlugin } from \"../core/define-plugin.js\";\n * import { addVitePlugin } from \"../utilities/add-vite-plugin.js\";\n * import type { Plugin as VitePlugin } from \"vite\"\n *\n * export const addVitePluginPlugin = definePlugin({\n * \t\tname: \"addVitePlugin\",\n * \t\thook: \"astro:config:setup\",\n * \t\timplementation: ({ updateConfig }) => (plugin: VitePlugin) => addVitePlugin({ plugin, updateConfig }),\n * });\n * ```\n */\nexport const definePlugin = <\n\tTName extends string,\n\tTHooks extends PluginHooksConstraint,\n>(\n\tplugin: Plugin<TName, THooks>,\n) => plugin;\n","import type { HookParameters, Hooks } from \"./types.js\";\n\n/**\n * Allows defining a type-safe function requiring all the params of a given hook.\n * It uses currying to make TypeScript happy.\n *\n * @param {string} _hook\n *\n * @see https://astro-integration-kit.netlify.app/utilities/define-utility/\n *\n * @example\n * ```ts\n * const test = defineUtility(\"astro:config:setup\")((params, foo: boolean) => {\n *  return \"bar\";\n * });\n * ```\n */\nexport const defineUtility =\n\t<THook extends keyof Hooks>(_hook: THook) =>\n\t/**\n\t * The function itself\n\t * @param {Function} fn;\n\t */\n\t<TFn extends (params: HookParameters<THook>, ...args: Array<any>) => any>(\n\t\tfn: TFn,\n\t) =>\n\t\tfn;\n","import type { AstroIntegration } from \"astro\";\nimport type { NonEmptyArray } from \"../internal/types.js\";\nimport type {\n\tAddedParam,\n\tAnyPlugin,\n\tExtendedHooks,\n\tHookParameters,\n\tHooks,\n} from \"./types.js\";\n\ntype WithPluginsParams<TPlugins extends NonEmptyArray<AnyPlugin>> = {\n\tname: string;\n\tplugins: TPlugins;\n\thooks: ExtendedHooks<TPlugins>;\n};\n\ntype WithPluginsReturn<Extensions> = Omit<\n\tExtensions,\n\t\"name\" | \"plugins\" | \"hooks\"\n> & {\n\thooks: AstroIntegration[\"hooks\"];\n};\n\n/**\n * Allows to extend hooks with custom parameters. Only used for advanced use-cases.\n *\n * @param {object} params\n * @param {string} params.name The integration name\n * @param {Array<AnyPlugin>} params.plugins\n * @param {import(\"astro\".AstroIntegration[\"hooks\"])} params.hooks\n */\nexport const withPlugins = <\n\tTPlugins extends NonEmptyArray<AnyPlugin>,\n\tExtensions extends Record<any, unknown>,\n>(\n\toptions: WithPluginsParams<TPlugins> & Extensions,\n): WithPluginsReturn<Extensions> => {\n\tconst {\n\t\tname,\n\t\tplugins,\n\t\thooks: providedHooks,\n\t\t...remainingIntegrationObject\n\t} = options;\n\n\t// Overrides plugins with same name\n\t// Overrides plugins with same name, keeping only the last occurrence\n\tconst resolvedPlugins = plugins\n\t\t.filter(\n\t\t\t(plugin, index, self) =>\n\t\t\t\tself.findLastIndex((other) => other.name === plugin.name) === index,\n\t\t)\n\t\t// Setup plugins with the integration parameters\n\t\t.map(\n\t\t\t(\n\t\t\t\tplugin,\n\t\t\t): Partial<\n\t\t\t\tRecord<keyof Hooks, (params: any) => Record<string, unknown>>\n\t\t\t> => plugin.setup({ name }),\n\t\t);\n\n\tconst definedHooks = Object.keys(providedHooks) as Array<keyof Hooks>;\n\n\tconst hooks: AstroIntegration[\"hooks\"] = Object.fromEntries(\n\t\tdefinedHooks.map((hookName) => [\n\t\t\thookName,\n\t\t\t// We know all hook parameters are objects, but the generic correlation makes TS ignore that fact.\n\t\t\t// The intersection with `object` is a workaround so TS doesn't complain about the spread below.\n\t\t\t(params: object & HookParameters<typeof hookName>) => {\n\t\t\t\tconst plugins = resolvedPlugins.filter(\n\t\t\t\t\t(p): p is Required<Pick<typeof p, typeof hookName>> =>\n\t\t\t\t\t\thookName in p && !!p[hookName],\n\t\t\t\t);\n\n\t\t\t\tconst additionalParams = {} as AddedParam<TPlugins, typeof hookName>;\n\n\t\t\t\tfor (const plugin of plugins) {\n\t\t\t\t\tObject.assign(additionalParams, plugin[hookName](params));\n\t\t\t\t}\n\n\t\t\t\treturn providedHooks[hookName]?.({\n\t\t\t\t\t...additionalParams,\n\t\t\t\t\t...params,\n\t\t\t\t} as any);\n\t\t\t},\n\t\t]),\n\t);\n\n\treturn {\n\t\thooks,\n\t\t...remainingIntegrationObject,\n\t};\n};\n","import { mkdirSync, readFileSync, writeFileSync } from \"node:fs\";\nimport { dirname, relative } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport type { AstroIntegrationLogger } from \"astro\";\nimport { parse, prettyPrint } from \"recast\";\nimport typescriptParser from \"recast/parsers/typescript.js\";\nimport { defineUtility } from \"../core/define-utility.js\";\n\nconst injectEnvDTS = ({\n\tsrcDir,\n\tlogger,\n\tspecifier,\n}: {\n\tsrcDir: URL;\n\tlogger: AstroIntegrationLogger;\n\tspecifier: URL | string;\n}) => {\n\tconst envDTsPath = fileURLToPath(new URL(\"env.d.ts\", srcDir));\n\n\tif (specifier instanceof URL) {\n\t\tspecifier = fileURLToPath(specifier);\n\t\tspecifier = relative(fileURLToPath(srcDir), specifier);\n\t\tspecifier = specifier.replaceAll(\"\\\\\", \"/\");\n\t}\n\n\tconst envDTsContents = readFileSync(envDTsPath, \"utf8\");\n\n\tif (envDTsContents.includes(`/// <reference types='${specifier}' />`)) {\n\t\treturn;\n\t}\n\tif (envDTsContents.includes(`/// <reference types=\"${specifier}\" />`)) {\n\t\treturn;\n\t}\n\n\tconst newEnvDTsContents = envDTsContents\n\t\t.replace(\n\t\t\t`/// <reference types='astro/client' />`,\n\t\t\t`/// <reference types='astro/client' />\\n/// <reference types='${specifier}' />`,\n\t\t)\n\t\t.replace(\n\t\t\t`/// <reference types=\"astro/client\" />`,\n\t\t\t`/// <reference types=\"astro/client\" />\\n/// <reference types=\"${specifier}\" />`,\n\t\t);\n\n\t// the odd case where the user changed the reference to astro/client\n\tif (newEnvDTsContents === envDTsContents) {\n\t\treturn;\n\t}\n\n\twriteFileSync(envDTsPath, newEnvDTsContents);\n\tlogger.info(\"Updated env.d.ts types\");\n};\n\n/**\n * Allows to inject .d.ts file in users project. It will create a file inside `.astro`\n * and reference it from `src/env.d.ts`.\n *\n * @param {import(\"astro\").HookParameters<\"astro:config:setup\">} params\n * @param {object} options\n * @param {string} options.name - The name of the .d.ts file. Eg `test` will generate `.astro/test.d.ts`\n * @param {string} options.content\n *\n * @example\n * ```ts\n * addDts(params, {\n * \t\tname: \"my-integration\",\n * \t \tcontent: `declare module \"virtual:my-integration\" {}`,\n * })\n * ```\n *\n * @see https://astro-integration-kit.netlify.app/utilities/add-dts/\n */\nexport const addDts = defineUtility(\"astro:config:setup\")(\n\t(\n\t\t{ config: { root, srcDir }, logger },\n\t\t{\n\t\t\tname,\n\t\t\tcontent,\n\t\t}: {\n\t\t\tname: string;\n\t\t\tcontent: string;\n\t\t},\n\t) => {\n\t\tconst dtsURL = new URL(`.astro/${name}.d.ts`, root);\n\t\tconst filePath = fileURLToPath(dtsURL);\n\n\t\tinjectEnvDTS({\n\t\t\tsrcDir,\n\t\t\tlogger,\n\t\t\tspecifier: dtsURL,\n\t\t});\n\n\t\tmkdirSync(dirname(filePath), { recursive: true });\n\t\twriteFileSync(\n\t\t\tfilePath,\n\t\t\tprettyPrint(\n\t\t\t\tparse(content, {\n\t\t\t\t\tparser: typescriptParser,\n\t\t\t\t}),\n\t\t\t\t{ tabWidth: 4 },\n\t\t\t).code,\n\t\t\t\"utf-8\",\n\t\t);\n\t},\n);\n","import { AstroError } from \"astro/errors\";\nimport type { Plugin } from \"vite\";\nimport { defineUtility } from \"../core/define-utility.js\";\nimport { addVitePlugin } from \"./add-vite-plugin.js\";\nimport { hasVitePlugin } from \"./has-vite-plugin.js\";\n\ntype VirtualImport = {\n\tid: string;\n\tcontent: string;\n\tcontext?: \"server\" | \"client\" | undefined;\n};\n\ntype Imports = Record<string, string> | Array<VirtualImport>;\n\nconst incrementPluginName = (name: string) => {\n\tlet count = 1;\n\treturn `${name.replace(/-(\\d+)$/, (_, c) => {\n\t\tcount = parseInt(c) + 1;\n\t\treturn \"\";\n\t})}-${count}`;\n};\n\nconst resolveVirtualModuleId = <T extends string>(id: T): `\\0${T}` => {\n\treturn `\\0${id}`;\n};\n\nconst createVirtualModule = (\n\tname: string,\n\t_imports: Imports,\n\tbypassCoreValidation: boolean,\n): Plugin => {\n\t// We normalize the imports into an array\n\tconst imports: Array<VirtualImport> = Array.isArray(_imports)\n\t\t? _imports\n\t\t: Object.entries(_imports).map(([id, content]) => ({\n\t\t\t\tid,\n\t\t\t\tcontent,\n\t\t\t\tcontext: undefined,\n\t\t  }));\n\n\t// We check for virtual imports with overlapping contexts, eg. several imports\n\t// with the same id and context server\n\tconst duplicatedImports: Record<string, Array<string>> = {};\n\tfor (const { id, context } of imports) {\n\t\tduplicatedImports[id] ??= [];\n\t\tduplicatedImports[id]?.push(\n\t\t\t...(context === undefined ? [\"server\", \"client\"] : [context]),\n\t\t);\n\t}\n\tfor (const [id, contexts] of Object.entries(duplicatedImports)) {\n\t\tif (contexts.length !== [...new Set(contexts)].length) {\n\t\t\tthrow new AstroError(\n\t\t\t\t`Virtual import with id \"${id}\" has been registered several times with conflicting contexts.`,\n\t\t\t);\n\t\t}\n\t}\n\n\tconst resolutionMap = Object.fromEntries(\n\t\timports.map(({ id }) => {\n\t\t\tif (!bypassCoreValidation && id.startsWith(\"astro:\")) {\n\t\t\t\tthrow new AstroError(\n\t\t\t\t\t`Virtual import name prefix can't be \"astro:\" (for \"${id}\") because it's reserved for Astro core.`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn [resolveVirtualModuleId(id), id];\n\t\t}),\n\t);\n\n\treturn {\n\t\tname,\n\t\tresolveId(id) {\n\t\t\tif (imports.find((_import) => _import.id === id)) {\n\t\t\t\treturn resolveVirtualModuleId(id);\n\t\t\t}\n\t\t\treturn;\n\t\t},\n\t\tload(id, options) {\n\t\t\tconst resolution = resolutionMap[id];\n\t\t\tif (resolution) {\n\t\t\t\tconst context = options?.ssr ? \"server\" : \"client\";\n\t\t\t\tconst data = imports.find(\n\t\t\t\t\t(_import) =>\n\t\t\t\t\t\t_import.id === resolution &&\n\t\t\t\t\t\t(_import.context === undefined || _import.context === context),\n\t\t\t\t);\n\n\t\t\t\tif (data) {\n\t\t\t\t\treturn data.content;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t},\n\t};\n};\n\n/**\n * Creates a Vite virtual module and updates the Astro config.\n * Virtual imports are useful for passing things like config options, or data computed within the integration.\n *\n * @param {import(\"astro\").HookParameters<\"astro:config:setup\">} params\n * @param {object} options\n * @param {string} options.name\n * @param {Imports} options.imports\n *\n * @see https://astro-integration-kit.netlify.app/utilities/add-virtual-imports/\n *\n * @example\n * ```ts\n * // my-integration/index.ts\n * import { addVirtualImports } from \"astro-integration-kit\";\n *\n * addVirtualImports(params, {\n * \t\tname: 'my-integration',\n * \t\timports: {\n * \t\t\t'virtual:my-integration/config': `export default ${ JSON.stringify({foo: \"bar\"}) }`,\n * \t\t},\n *\t});\n * ```\n *\n * This is then readable anywhere else in your integration:\n *\n * ```ts\n * // myIntegration/src/component/layout.astro\n * import config from \"virtual:my-integration/config\";\n *\n * console.log(config.foo) // \"bar\"\n * ```\n */\nexport const addVirtualImports = defineUtility(\"astro:config:setup\")(\n\t(\n\t\tparams,\n\t\t{\n\t\t\tname,\n\t\t\timports,\n\t\t\t__enableCorePowerDoNotUseOrYouWillBeFired = false,\n\t\t}: {\n\t\t\tname: string;\n\t\t\timports: Imports;\n\t\t\t__enableCorePowerDoNotUseOrYouWillBeFired?: boolean;\n\t\t},\n\t) => {\n\t\tlet pluginName = `vite-plugin-${name}`;\n\n\t\twhile (hasVitePlugin(params, { plugin: pluginName }))\n\t\t\tpluginName = incrementPluginName(pluginName);\n\n\t\taddVitePlugin(params, {\n\t\t\twarnDuplicated: false,\n\t\t\tplugin: createVirtualModule(\n\t\t\t\tpluginName,\n\t\t\t\timports,\n\t\t\t\t__enableCorePowerDoNotUseOrYouWillBeFired,\n\t\t\t),\n\t\t});\n\t},\n);\n","import type { AstroConfig } from \"astro\";\nimport type { PluginOption } from \"vite\";\nimport { defineUtility } from \"../core/define-utility.js\";\n\nfunction getPluginNames(plugins: AstroConfig[\"vite\"][\"plugins\"]) {\n\tconst names: string[] = [];\n\n\tif (plugins) {\n\t\tfor (const plugin of plugins) {\n\t\t\tif (!plugin) continue;\n\n\t\t\tif (Array.isArray(plugin)) {\n\t\t\t\tnames.push(...getPluginNames(plugin));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (plugin instanceof Promise) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnames.push(plugin.name);\n\t\t}\n\t}\n\n\treturn names;\n}\n\n/**\n * Checks for the existence of a Vite plugin inside the Astro config.\n *\n * @param {import(\"astro\").HookParameters<\"astro:config:setup\">} params\n * @param {Params} options\n * @param {string | import(\"vite\").PluginOption} options.plugin\n *\n * @see https://astro-integration-kit.netlify.app/utilities/has-vite-plugin/\n *\n * @example\n * ```ts\n * hasVitePlugin(params, {\n * \t\tplugin: \"vite-plugin-my-integration\",\n * })\n * ```\n */\nexport const hasVitePlugin = defineUtility(\"astro:config:setup\")(\n\t(\n\t\t{ config },\n\t\t{\n\t\t\tplugin,\n\t\t}: {\n\t\t\tplugin: string | PluginOption;\n\t\t},\n\t): boolean => {\n\t\tif (!plugin || plugin instanceof Promise) return false;\n\n\t\tconst currentPlugins = new Set(getPluginNames(config?.vite?.plugins));\n\n\t\tconst plugins = new Set<string>();\n\n\t\tif (typeof plugin === \"string\") {\n\t\t\tplugins.add(plugin);\n\t\t}\n\n\t\tif (typeof plugin === \"object\") {\n\t\t\tif (Array.isArray(plugin)) {\n\t\t\t\tconst names = new Set(\n\t\t\t\t\tgetPluginNames(plugin as NonNullable<AstroConfig[\"vite\"][\"plugins\"]>),\n\t\t\t\t);\n\t\t\t\tfor (const name of names) plugins.add(name);\n\t\t\t} else {\n\t\t\t\tplugins.add(plugin.name);\n\t\t\t}\n\t\t}\n\n\t\treturn [...plugins].some((name) => currentPlugins.has(name));\n\t},\n);\n","import type { Plugin, PluginOption } from \"vite\";\nimport { defineUtility } from \"../core/define-utility.js\";\nimport { hasVitePlugin } from \"./has-vite-plugin.js\";\n\n/**\n * Adds a [vite plugin](https://vitejs.dev/guide/using-plugins) to the\n * Astro config.\n *\n * @param {import(\"astro\").HookParameters<\"astro:config:setup\">} params\n * @param {object} options\n * @param {import(\"vite\").PluginOption} options.plugin\n * @param {boolean} [options.warnDuplicated=true]\n *\n * @see https://astro-integration-kit.netlify.app/utilities/add-vite-plugin/\n *\n * @example\n * ```ts\n * addVitePlugin(params, {\n * \t\tplugin,\n * \t\twarnDuplicated: true,\n * })\n * ```\n */\nexport const addVitePlugin = defineUtility(\"astro:config:setup\")(\n\t(\n\t\tparams,\n\t\t{\n\t\t\tplugin,\n\t\t\twarnDuplicated = true,\n\t\t}: {\n\t\t\tplugin: PluginOption;\n\t\t\twarnDuplicated?: boolean;\n\t\t},\n\t) => {\n\t\tconst { updateConfig, logger } = params;\n\n\t\tif (warnDuplicated && hasVitePlugin(params, { plugin })) {\n\t\t\tlogger.warn(\n\t\t\t\t`The Vite plugin \"${\n\t\t\t\t\t(plugin as Plugin).name\n\t\t\t\t}\" is already present in your Vite configuration, this plugin may not behave correctly.`,\n\t\t\t);\n\t\t}\n\n\t\tupdateConfig({\n\t\t\tvite: {\n\t\t\t\tplugins: [plugin],\n\t\t\t},\n\t\t});\n\t},\n);\n","import { AstroError } from \"astro/errors\";\nimport { defineUtility } from \"../core/define-utility.js\";\n\ntype HasIntegrationParams = (\n\t| { position?: undefined; relativeTo?: string }\n\t| { position: \"before\" | \"after\"; relativeTo: string }\n) & {\n\tname: string;\n};\n\n/**\n * Checks whether an integration is already installed.\n *\n * If `before` is given, returns true only if the integration is installed before the named|provided integration.\n * If `after` is given, returns true only if the integration is installed after the named|provided integration.\n *\n * @param {import(\"astro\").HookParameters<\"astro:config:setup\">} params\n * @param {object} options\n * @param {string} options.name - Integration to look up.\n * @param {undefined | \"before\" | \"after\"} options.position - Position in relation to another integration to check.\n * @param {undefined | string} options.relativeTo - Other integration to check for relative poisition.\n *\n * @returns {boolean}\n *\n * @throws {AstroError} When `params.position` is defined but `params.relativeTo` isn't.\n *\n * @see https://astro-integration-kit.netlify.app/utilities/has-integration/\n *\n * @example\n * ```ts\n * hasIntegration(params, {\n * \t\tname: \"@astrojs/tailwind\",\n * })\n * ```\n */\nexport const hasIntegration = defineUtility(\"astro:config:setup\")(\n\t(\n\t\t{ config },\n\t\t{ name, position, relativeTo }: HasIntegrationParams,\n\t): boolean => {\n\t\tconst integrationPosition = config.integrations.findIndex(\n\t\t\t(integration) => integration.name === name,\n\t\t);\n\n\t\t// Integration is not installed\n\t\tif (integrationPosition === -1) return false;\n\n\t\t// Not a relative check, the integration is present.\n\t\tif (position === undefined) return true;\n\n\t\tif (relativeTo === undefined)\n\t\t\tthrow new AstroError(\n\t\t\t\t\"Cannot perform a relative integration check without a relative reference.\",\n\t\t\t\t\"Pass `relativeTo` on your call to `hasIntegration` or remove the `position` option.\",\n\t\t\t);\n\n\t\tconst otherPosition = config.integrations.findIndex(\n\t\t\t(integration) => integration.name === relativeTo,\n\t\t);\n\n\t\tif (otherPosition === -1)\n\t\t\tthrow new AstroError(\n\t\t\t\t\"Cannot check relative position against an absent integration.\",\n\t\t\t);\n\n\t\treturn position === \"before\"\n\t\t\t? integrationPosition < otherPosition\n\t\t\t: integrationPosition > otherPosition;\n\t},\n);\n","import type { InjectedRoute } from \"astro\";\nimport { defineUtility } from \"../core/define-utility.js\";\n\n/**\n * Allows you to inject a route in development only\n *\n * @param {import(\"astro\").HookParameters<\"astro:config:setup\">} params\n * @param {object} options\n * @param {import(\"astro\").InjectedRoute} options.injectedRoute\n *\n * @example\n * ```ts\n * injectDevRoute(params, {\n * \t\tpattern: \"/foo\",\n * \t\tentrypoint: resolve(\"./pages/foo.astro\")\n * })\n * ```\n *\n * @see https://astro-integration-kit.netlify.app/utilities/inject-dev-route/\n */\nexport const injectDevRoute = defineUtility(\"astro:config:setup\")(\n\t({ command, injectRoute }, injectedRoute: InjectedRoute) => {\n\t\tif (command === \"dev\") {\n\t\t\tinjectRoute(injectedRoute);\n\t\t}\n\t},\n);\n","import { readdirSync, statSync } from \"node:fs\";\nimport { join, relative, resolve } from \"pathe\";\nimport { defineUtility } from \"../core/define-utility.js\";\n\nconst getFilesRecursively = (dir: string, baseDir = dir) => {\n\tconst files = readdirSync(dir);\n\tlet filepaths: Array<string> = [];\n\n\tfor (const file of files) {\n\t\tconst filepath = join(dir, file);\n\t\tconst _stat = statSync(filepath);\n\n\t\tif (_stat.isDirectory()) {\n\t\t\t// Recursively get files from subdirectories\n\t\t\tconst subDirectoryFiles = getFilesRecursively(filepath, baseDir);\n\t\t\tfilepaths = filepaths.concat(subDirectoryFiles);\n\t\t} else {\n\t\t\t// Calculate relative path and add it to the array\n\t\t\tconst relativePath = relative(baseDir, filepath);\n\t\t\tfilepaths.push(relativePath);\n\t\t}\n\t}\n\n\treturn filepaths;\n};\n\n/**\n * In development, will reload the Astro dev server if any files within\n * the directory has changed.\n *\n * @param {import(\"astro\").HookParameters<\"astro:config:setup\">} params\n * @param {string} directory\n *\n * @see https://astro-integration-kit.netlify.app/utilities/watch-directory/\n *\n * @example\n * ```ts\n * watchDirectory(params, resolve())\n * ```\n */\nexport const watchDirectory = defineUtility(\"astro:config:setup\")(\n\t({ addWatchFile, command, updateConfig }, directory: string) => {\n\t\tif (command !== \"dev\") {\n\t\t\treturn;\n\t\t}\n\n\t\tconst paths = getFilesRecursively(directory).map((p) =>\n\t\t\tresolve(directory, p),\n\t\t);\n\n\t\tfor (const path of paths) {\n\t\t\taddWatchFile(path);\n\t\t}\n\n\t\tupdateConfig({\n\t\t\tvite: {\n\t\t\t\tplugins: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: `rollup-aik-watch-directory-${directory}`,\n\t\t\t\t\t\tbuildStart() {\n\t\t\t\t\t\t\tfor (const path of paths) {\n\t\t\t\t\t\t\t\tthis.addWatchFile(path);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t});\n\t},\n);\n","import { type AstroIntegration } from \"astro\";\nimport { defineUtility } from \"../core/define-utility.js\";\nimport { hasIntegration } from \"./has-integration.js\";\n\nexport type AddIntegrationParams = {\n\tintegration: AstroIntegration;\n\tensureUnique?: boolean | undefined;\n};\n\n/**\n * Easily add an integration from within an integration.\n *\n * @param {import(\"astro\").HookParameters<\"astro:config:setup\">} params\n * @param {object} options\n * @param {import(\"astro\").AstroIntegration} options.integration\n * @param {boolean} options.ensureUnique\n *\n * @example\n * ```ts\n * import Vue from \"@astrojs/vue\";\n *\n * addIntegration(params, {\n * \tintegration: Vue(),\n * \tensureUnique: true,\n * })\n * ```\n *\n * @see https://astro-integration-kit.netlify.app/utilities/add-integration/\n */\nexport const addIntegration = defineUtility(\"astro:config:setup\")(\n\t(params, { integration, ensureUnique }: AddIntegrationParams) => {\n\t\tconst { logger, updateConfig } = params;\n\t\tif (\n\t\t\tensureUnique &&\n\t\t\thasIntegration(params, {\n\t\t\t\tname: integration.name,\n\t\t\t})\n\t\t) {\n\t\t\tlogger.warn(\n\t\t\t\t`Integration \"${integration.name}\" has already been added by the user or another integration. Skipping.`,\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\tupdateConfig({\n\t\t\tintegrations: [integration],\n\t\t});\n\t},\n);\n"],"mappings":"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","names":["fileURLToPath","dirname","resolve","createResolver","_base","base","path","AstroError","z","errorMap","baseError","ctx","baseErrorPath","flattenErrorPath","typeOrLiteralErrByPath","unionError","e","flattenedErrorPath","prefix","error","key","getTypeOrLiteralMsg","expectedDeduped","unionExpectedVals","msg","expectedVals","expectedVal","idx","errorPath","defineIntegration","name","optionsSchema","setup","args","parsedOptions","z","errorMap","AstroError","i","options","integration","definePlugin","plugin","defineUtility","_hook","fn","withPlugins","options","name","plugins","providedHooks","remainingIntegrationObject","resolvedPlugins","plugin","index","self","other","definedHooks","hookName","params","p","additionalParams","mkdirSync","readFileSync","writeFileSync","dirname","relative","fileURLToPath","parse","prettyPrint","typescriptParser","injectEnvDTS","srcDir","logger","specifier","envDTsPath","fileURLToPath","relative","envDTsContents","readFileSync","newEnvDTsContents","writeFileSync","addDts","defineUtility","root","name","content","dtsURL","filePath","mkdirSync","dirname","prettyPrint","parse","typescriptParser","AstroError","getPluginNames","plugins","names","plugin","hasVitePlugin","defineUtility","config","currentPlugins","name","addVitePlugin","defineUtility","params","plugin","warnDuplicated","updateConfig","logger","hasVitePlugin","incrementPluginName","name","count","_","c","resolveVirtualModuleId","id","createVirtualModule","_imports","bypassCoreValidation","imports","content","duplicatedImports","context","contexts","AstroError","resolutionMap","_import","options","resolution","data","addVirtualImports","defineUtility","params","__enableCorePowerDoNotUseOrYouWillBeFired","pluginName","hasVitePlugin","addVitePlugin","AstroError","hasIntegration","defineUtility","config","name","position","relativeTo","integrationPosition","integration","AstroError","otherPosition","injectDevRoute","defineUtility","command","injectRoute","injectedRoute","readdirSync","statSync","join","relative","resolve","getFilesRecursively","dir","baseDir","files","readdirSync","filepaths","file","filepath","join","statSync","subDirectoryFiles","relativePath","relative","watchDirectory","defineUtility","addWatchFile","command","updateConfig","directory","paths","p","resolve","path","addIntegration","defineUtility","params","integration","ensureUnique","logger","updateConfig","hasIntegration"]}