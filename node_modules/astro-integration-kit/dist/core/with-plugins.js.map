{"version":3,"sources":["../../src/core/with-plugins.ts"],"sourcesContent":["import type { AstroIntegration } from \"astro\";\nimport type { NonEmptyArray } from \"../internal/types.js\";\nimport type {\n\tAddedParam,\n\tAnyPlugin,\n\tExtendedHooks,\n\tHookParameters,\n\tHooks,\n} from \"./types.js\";\n\ntype WithPluginsParams<TPlugins extends NonEmptyArray<AnyPlugin>> = {\n\tname: string;\n\tplugins: TPlugins;\n\thooks: ExtendedHooks<TPlugins>;\n};\n\ntype WithPluginsReturn<Extensions> = Omit<\n\tExtensions,\n\t\"name\" | \"plugins\" | \"hooks\"\n> & {\n\thooks: AstroIntegration[\"hooks\"];\n};\n\n/**\n * Allows to extend hooks with custom parameters. Only used for advanced use-cases.\n *\n * @param {object} params\n * @param {string} params.name The integration name\n * @param {Array<AnyPlugin>} params.plugins\n * @param {import(\"astro\".AstroIntegration[\"hooks\"])} params.hooks\n */\nexport const withPlugins = <\n\tTPlugins extends NonEmptyArray<AnyPlugin>,\n\tExtensions extends Record<any, unknown>,\n>(\n\toptions: WithPluginsParams<TPlugins> & Extensions,\n): WithPluginsReturn<Extensions> => {\n\tconst {\n\t\tname,\n\t\tplugins,\n\t\thooks: providedHooks,\n\t\t...remainingIntegrationObject\n\t} = options;\n\n\t// Overrides plugins with same name\n\t// Overrides plugins with same name, keeping only the last occurrence\n\tconst resolvedPlugins = plugins\n\t\t.filter(\n\t\t\t(plugin, index, self) =>\n\t\t\t\tself.findLastIndex((other) => other.name === plugin.name) === index,\n\t\t)\n\t\t// Setup plugins with the integration parameters\n\t\t.map(\n\t\t\t(\n\t\t\t\tplugin,\n\t\t\t): Partial<\n\t\t\t\tRecord<keyof Hooks, (params: any) => Record<string, unknown>>\n\t\t\t> => plugin.setup({ name }),\n\t\t);\n\n\tconst definedHooks = Object.keys(providedHooks) as Array<keyof Hooks>;\n\n\tconst hooks: AstroIntegration[\"hooks\"] = Object.fromEntries(\n\t\tdefinedHooks.map((hookName) => [\n\t\t\thookName,\n\t\t\t// We know all hook parameters are objects, but the generic correlation makes TS ignore that fact.\n\t\t\t// The intersection with `object` is a workaround so TS doesn't complain about the spread below.\n\t\t\t(params: object & HookParameters<typeof hookName>) => {\n\t\t\t\tconst plugins = resolvedPlugins.filter(\n\t\t\t\t\t(p): p is Required<Pick<typeof p, typeof hookName>> =>\n\t\t\t\t\t\thookName in p && !!p[hookName],\n\t\t\t\t);\n\n\t\t\t\tconst additionalParams = {} as AddedParam<TPlugins, typeof hookName>;\n\n\t\t\t\tfor (const plugin of plugins) {\n\t\t\t\t\tObject.assign(additionalParams, plugin[hookName](params));\n\t\t\t\t}\n\n\t\t\t\treturn providedHooks[hookName]?.({\n\t\t\t\t\t...additionalParams,\n\t\t\t\t\t...params,\n\t\t\t\t} as any);\n\t\t\t},\n\t\t]),\n\t);\n\n\treturn {\n\t\thooks,\n\t\t...remainingIntegrationObject,\n\t};\n};\n"],"mappings":"AA+BO,IAAMA,EAIZC,GACmC,CACnC,GAAM,CACL,KAAAC,EACA,QAAAC,EACA,MAAOC,EACP,GAAGC,CACJ,EAAIJ,EAIEK,EAAkBH,EACtB,OACA,CAACI,EAAQC,EAAOC,IACfA,EAAK,cAAeC,GAAUA,EAAM,OAASH,EAAO,IAAI,IAAMC,CAChE,EAEC,IAECD,GAGIA,EAAO,MAAM,CAAE,KAAAL,CAAK,CAAC,CAC3B,EAEKS,EAAe,OAAO,KAAKP,CAAa,EA2B9C,MAAO,CACN,MA1BwC,OAAO,YAC/CO,EAAa,IAAKC,GAAa,CAC9BA,EAGCC,GAAqD,CACrD,IAAMV,EAAUG,EAAgB,OAC9BQ,GACAF,KAAYE,GAAK,CAAC,CAACA,EAAEF,CAAQ,CAC/B,EAEMG,EAAmB,CAAC,EAE1B,QAAWR,KAAUJ,EACpB,OAAO,OAAOY,EAAkBR,EAAOK,CAAQ,EAAEC,CAAM,CAAC,EAGzD,OAAOT,EAAcQ,CAAQ,IAAI,CAChC,GAAGG,EACH,GAAGF,CACJ,CAAQ,CACT,CACD,CAAC,CACF,EAIC,GAAGR,CACJ,CACD","names":["withPlugins","options","name","plugins","providedHooks","remainingIntegrationObject","resolvedPlugins","plugin","index","self","other","definedHooks","hookName","params","p","additionalParams"]}