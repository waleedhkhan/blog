import{fileURLToPath as $}from"node:url";import{dirname as E,resolve as j}from"pathe";var H=t=>{let e=t;return e.startsWith("file://")&&(e=E($(e))),{resolve:(...n)=>j(e,...n)}};import{AstroError as b}from"astro/errors";import{z as U}from"astro/zod";var I=(t,e)=>{let n=A(t.path);if(t.code==="invalid_union"){let o=new Map;for(let r of t.unionErrors.flatMap(s=>s.errors))if(r.code==="invalid_type"||r.code==="invalid_literal"){let s=A(r.path);o.has(s)?o.get(s).expected.push(r.expected):o.set(s,{code:r.code,received:r.received,expected:[r.expected]})}return{message:[u(n,o.size?"Did not match union:":"Did not match union.")].concat([...o.entries()].filter(([,r])=>r.expected.length===t.unionErrors.length).map(([r,s])=>r===n?`> ${h(s)}`:`> ${u(r,h(s))}`)).join(`
`)}}return t.code==="invalid_literal"||t.code==="invalid_type"?{message:u(n,h({code:t.code,received:t.received,expected:[t.expected]}))}:t.message?{message:u(n,t.message)}:{message:u(n,e.defaultError)}},h=t=>{if(t.received==="undefined")return"Required";let e=new Set(t.expected);switch(t.code){case"invalid_type":return`Expected type \`${T(e)}\`, received ${JSON.stringify(t.received)}`;case"invalid_literal":return`Expected \`${T(e)}\`, received ${JSON.stringify(t.received)}`}},u=(t,e)=>t.length?`**${t}**: ${e}`:e,T=t=>[...t].map((e,n)=>n===0?JSON.stringify(e):` | ${JSON.stringify(e)}`).join(""),A=t=>t.join(".");var V=({name:t,optionsSchema:e,setup:n})=>(...o)=>{let i=(e??U.never().optional()).safeParse(o[0],{errorMap:I});if(!i.success)throw new b(`Invalid options passed to "${t}" integration
`,i.error.issues.map(a=>a.message).join(`
`));let r=i.data,s=n({name:t,options:r});return{name:t,...s}};var D=t=>t;var p=t=>e=>e;var L=t=>{let{name:e,plugins:n,hooks:o,...i}=t,r=n.filter((c,f,l)=>l.findLastIndex(d=>d.name===c.name)===f).map(c=>c.setup({name:e})),s=Object.keys(o);return{hooks:Object.fromEntries(s.map(c=>[c,f=>{let l=r.filter(g=>c in g&&!!g[c]),d={};for(let g of l)Object.assign(d,g[c](f));return o[c]?.({...d,...f})}])),...i}};import{mkdirSync as N,readFileSync as z,writeFileSync as k}from"node:fs";import{dirname as C,relative as F}from"node:path";import{fileURLToPath as y}from"node:url";import{parse as _,prettyPrint as M}from"recast";import W from"recast/parsers/typescript.js";var B=({srcDir:t,logger:e,specifier:n})=>{let o=y(new URL("env.d.ts",t));n instanceof URL&&(n=y(n),n=F(y(t),n),n=n.replaceAll("\\","/"));let i=z(o,"utf8");if(i.includes(`/// <reference types='${n}' />`)||i.includes(`/// <reference types="${n}" />`))return;let r=i.replace("/// <reference types='astro/client' />",`/// <reference types='astro/client' />
/// <reference types='${n}' />`).replace('/// <reference types="astro/client" />',`/// <reference types="astro/client" />
/// <reference types="${n}" />`);r!==i&&(k(o,r),e.info("Updated env.d.ts types"))},Z=p("astro:config:setup")(({config:{root:t,srcDir:e},logger:n},{name:o,content:i})=>{let r=new URL(`.astro/${o}.d.ts`,t),s=y(r);B({srcDir:e,logger:n,specifier:r}),N(C(s),{recursive:!0}),k(s,M(_(i,{parser:W}),{tabWidth:4}).code,"utf-8")});import{AstroError as w}from"astro/errors";function P(t){let e=[];if(t){for(let n of t)if(n){if(Array.isArray(n)){e.push(...P(n));continue}n instanceof Promise||e.push(n.name)}}return e}var m=p("astro:config:setup")(({config:t},{plugin:e})=>{if(!e||e instanceof Promise)return!1;let n=new Set(P(t?.vite?.plugins)),o=new Set;if(typeof e=="string"&&o.add(e),typeof e=="object")if(Array.isArray(e)){let i=new Set(P(e));for(let r of i)o.add(r)}else o.add(e.name);return[...o].some(i=>n.has(i))});var x=p("astro:config:setup")((t,{plugin:e,warnDuplicated:n=!0})=>{let{updateConfig:o,logger:i}=t;n&&m(t,{plugin:e})&&i.warn(`The Vite plugin "${e.name}" is already present in your Vite configuration, this plugin may not behave correctly.`),o({vite:{plugins:[e]}})});var J=t=>{let e=1;return`${t.replace(/-(\d+)$/,(n,o)=>(e=parseInt(o)+1,""))}-${e}`},S=t=>`\0${t}`,q=(t,e,n)=>{let o=Array.isArray(e)?e:Object.entries(e).map(([s,a])=>({id:s,content:a,context:void 0})),i={};for(let{id:s,context:a}of o)i[s]??=[],i[s]?.push(...a===void 0?["server","client"]:[a]);for(let[s,a]of Object.entries(i))if(a.length!==[...new Set(a)].length)throw new w(`Virtual import with id "${s}" has been registered several times with conflicting contexts.`);let r=Object.fromEntries(o.map(({id:s})=>{if(!n&&s.startsWith("astro:"))throw new w(`Virtual import name prefix can't be "astro:" (for "${s}") because it's reserved for Astro core.`);return[S(s),s]}));return{name:t,resolveId(s){if(o.find(a=>a.id===s))return S(s)},load(s,a){let c=r[s];if(c){let f=a?.ssr?"server":"client",l=o.find(d=>d.id===c&&(d.context===void 0||d.context===f));if(l)return l.content}}}},Y=p("astro:config:setup")((t,{name:e,imports:n,__enableCorePowerDoNotUseOrYouWillBeFired:o=!1})=>{let i=`vite-plugin-${e}`;for(;m(t,{plugin:i});)i=J(i);x(t,{warnDuplicated:!1,plugin:q(i,n,o)})});import{AstroError as O}from"astro/errors";var v=p("astro:config:setup")(({config:t},{name:e,position:n,relativeTo:o})=>{let i=t.integrations.findIndex(s=>s.name===e);if(i===-1)return!1;if(n===void 0)return!0;if(o===void 0)throw new O("Cannot perform a relative integration check without a relative reference.","Pass `relativeTo` on your call to `hasIntegration` or remove the `position` option.");let r=t.integrations.findIndex(s=>s.name===o);if(r===-1)throw new O("Cannot check relative position against an absent integration.");return n==="before"?i<r:i>r});var G=p("astro:config:setup")(({command:t,injectRoute:e},n)=>{t==="dev"&&e(n)});import{readdirSync as K,statSync as Q}from"node:fs";import{join as X,relative as tt,resolve as et}from"pathe";var R=(t,e=t)=>{let n=K(t),o=[];for(let i of n){let r=X(t,i);if(Q(r).isDirectory()){let a=R(r,e);o=o.concat(a)}else{let a=tt(e,r);o.push(a)}}return o},nt=p("astro:config:setup")(({addWatchFile:t,command:e,updateConfig:n},o)=>{if(e!=="dev")return;let i=R(o).map(r=>et(o,r));for(let r of i)t(r);n({vite:{plugins:[{name:`rollup-aik-watch-directory-${o}`,buildStart(){for(let r of i)this.addWatchFile(r)}}]}})});import"astro";var ot=p("astro:config:setup")((t,{integration:e,ensureUnique:n})=>{let{logger:o,updateConfig:i}=t;if(n&&v(t,{name:e.name})){o.warn(`Integration "${e.name}" has already been added by the user or another integration. Skipping.`);return}i({integrations:[e]})});export{Z as addDts,ot as addIntegration,Y as addVirtualImports,x as addVitePlugin,H as createResolver,V as defineIntegration,D as definePlugin,p as defineUtility,v as hasIntegration,m as hasVitePlugin,G as injectDevRoute,nt as watchDirectory,L as withPlugins};
//# sourceMappingURL=index.js.map