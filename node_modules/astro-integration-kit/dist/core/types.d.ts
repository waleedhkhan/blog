import * as astro from 'astro';
import { DevToolbarApp } from 'astro';
import { Prettify } from '../internal/types.js';

type PluginHooksConstraint = {
    [Hook in keyof Hooks]?: (...args: Parameters<Hooks[Hook]>) => Record<string, unknown>;
};
type Plugin<TName extends string, THooks extends PluginHooksConstraint> = {
    name: TName;
    setup: (params: {
        name: string;
    }) => THooks;
};
type AnyPlugin = Plugin<string, Record<string, unknown>>;
declare global {
    namespace AstroIntegrationKit {
        interface ExtraHooks {
        }
    }
}
type Hooks = Prettify<Required<NonNullable<astro.AstroIntegration["hooks"]>> & AstroIntegrationKit.ExtraHooks>;
type HookParameters<T extends keyof Hooks> = Parameters<Hooks[T]>[0];
type AnyFunction = (...args: Array<any>) => any;
/**
 * Turn the plugin into a simplified type representation of itself that can be more easily manipulated.
 *
 * No value of this type exists at runtime, it's only used for type manipulation.
 */
type SimplifyPlugin<TPlugin extends AnyPlugin = AnyPlugin> = {
    name: TPlugin["name"];
    hooks: {
        [K in keyof ReturnType<TPlugin["setup"]>]: ReturnType<TPlugin["setup"]>[K] extends AnyFunction ? ReturnType<ReturnType<TPlugin["setup"]>[K]> : never;
    };
};
/**
 * Return a tuple of simplified plugins that affect the given hook.
 *
 * Plugins that don't affect the hook are removed from the tuple. The order of the tuple is preserved.
 *
 * @internal
 */
type FilterPluginsByHook<THook extends keyof Hooks, TPlugins extends Array<AnyPlugin>> = TPlugins extends [infer Head, ...infer Tail] ? Head extends AnyPlugin ? Tail extends Array<AnyPlugin> ? undefined extends SimplifyPlugin<Head>["hooks"][THook] ? FilterPluginsByHook<THook, Tail> : [SimplifyPlugin<Head>, ...FilterPluginsByHook<THook, Tail>] : [] : [] : [];
type OmitKeysByValue<T, ValueType> = {
    [Key in keyof T as T[Key] extends ValueType ? never : Key]: T[Key];
};
type OverridePluginParamsForHook<THook extends keyof Hooks, TPlugins extends Array<SimplifyPlugin>> = TPlugins extends [...infer Head, infer Tail] ? Tail extends SimplifyPlugin ? Head extends SimplifyPlugin[] ? Omit<OverridePluginParamsForHook<THook, Head>, keyof Tail["hooks"][THook]> & Tail["hooks"][THook] : never : never : Record<never, never>;
/**
 * Compute plugin-added parameters for a hook.
 *
 * Plugins are applied in order, so the last plugin to define a parameter wins.
 * Plugins that don't define any value for the given hook are ignored.
 *
 * @internal
 */
type AddedParam<TPlugins extends Array<AnyPlugin>, THook extends keyof Hooks> = Prettify<OmitKeysByValue<OverridePluginParamsForHook<THook, FilterPluginsByHook<THook, TPlugins>>, never>>;
/**
 * Extend the signature of a function to receive extra parameters.
 *
 * Used to inject plugin-defined parameters into hooks.
 */
type AddParam<Func, Param = never> = [Param] extends [never] ? Func : Func extends (params: infer Params) => infer ReturnType ? (params: Params & Param) => ReturnType : never;
type ExtendedHooks<TPlugins extends Array<AnyPlugin>> = {
    [Hook in keyof Hooks]?: Hooks[Hook] extends AnyFunction ? AddParam<Hooks[Hook], AddedParam<TPlugins, Hook>> : never;
};
interface DevToolbarFrameworkAppProps {
    canvas: Parameters<Required<DevToolbarApp>["init"]>[0];
    eventTarget: Parameters<Required<DevToolbarApp>["init"]>[1];
    renderWindow: HTMLElementTagNameMap["astro-dev-toolbar-window"];
}

export type { AddedParam, AnyPlugin, DevToolbarFrameworkAppProps, ExtendedHooks, HookParameters, Hooks, Plugin, PluginHooksConstraint };
