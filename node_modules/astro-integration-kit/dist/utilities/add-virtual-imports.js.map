{"version":3,"sources":["../../src/utilities/add-virtual-imports.ts","../../src/core/define-utility.ts","../../src/utilities/has-vite-plugin.ts","../../src/utilities/add-vite-plugin.ts"],"sourcesContent":["import { AstroError } from \"astro/errors\";\nimport type { Plugin } from \"vite\";\nimport { defineUtility } from \"../core/define-utility.js\";\nimport { addVitePlugin } from \"./add-vite-plugin.js\";\nimport { hasVitePlugin } from \"./has-vite-plugin.js\";\n\ntype VirtualImport = {\n\tid: string;\n\tcontent: string;\n\tcontext?: \"server\" | \"client\" | undefined;\n};\n\ntype Imports = Record<string, string> | Array<VirtualImport>;\n\nconst incrementPluginName = (name: string) => {\n\tlet count = 1;\n\treturn `${name.replace(/-(\\d+)$/, (_, c) => {\n\t\tcount = parseInt(c) + 1;\n\t\treturn \"\";\n\t})}-${count}`;\n};\n\nconst resolveVirtualModuleId = <T extends string>(id: T): `\\0${T}` => {\n\treturn `\\0${id}`;\n};\n\nconst createVirtualModule = (\n\tname: string,\n\t_imports: Imports,\n\tbypassCoreValidation: boolean,\n): Plugin => {\n\t// We normalize the imports into an array\n\tconst imports: Array<VirtualImport> = Array.isArray(_imports)\n\t\t? _imports\n\t\t: Object.entries(_imports).map(([id, content]) => ({\n\t\t\t\tid,\n\t\t\t\tcontent,\n\t\t\t\tcontext: undefined,\n\t\t  }));\n\n\t// We check for virtual imports with overlapping contexts, eg. several imports\n\t// with the same id and context server\n\tconst duplicatedImports: Record<string, Array<string>> = {};\n\tfor (const { id, context } of imports) {\n\t\tduplicatedImports[id] ??= [];\n\t\tduplicatedImports[id]?.push(\n\t\t\t...(context === undefined ? [\"server\", \"client\"] : [context]),\n\t\t);\n\t}\n\tfor (const [id, contexts] of Object.entries(duplicatedImports)) {\n\t\tif (contexts.length !== [...new Set(contexts)].length) {\n\t\t\tthrow new AstroError(\n\t\t\t\t`Virtual import with id \"${id}\" has been registered several times with conflicting contexts.`,\n\t\t\t);\n\t\t}\n\t}\n\n\tconst resolutionMap = Object.fromEntries(\n\t\timports.map(({ id }) => {\n\t\t\tif (!bypassCoreValidation && id.startsWith(\"astro:\")) {\n\t\t\t\tthrow new AstroError(\n\t\t\t\t\t`Virtual import name prefix can't be \"astro:\" (for \"${id}\") because it's reserved for Astro core.`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn [resolveVirtualModuleId(id), id];\n\t\t}),\n\t);\n\n\treturn {\n\t\tname,\n\t\tresolveId(id) {\n\t\t\tif (imports.find((_import) => _import.id === id)) {\n\t\t\t\treturn resolveVirtualModuleId(id);\n\t\t\t}\n\t\t\treturn;\n\t\t},\n\t\tload(id, options) {\n\t\t\tconst resolution = resolutionMap[id];\n\t\t\tif (resolution) {\n\t\t\t\tconst context = options?.ssr ? \"server\" : \"client\";\n\t\t\t\tconst data = imports.find(\n\t\t\t\t\t(_import) =>\n\t\t\t\t\t\t_import.id === resolution &&\n\t\t\t\t\t\t(_import.context === undefined || _import.context === context),\n\t\t\t\t);\n\n\t\t\t\tif (data) {\n\t\t\t\t\treturn data.content;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t},\n\t};\n};\n\n/**\n * Creates a Vite virtual module and updates the Astro config.\n * Virtual imports are useful for passing things like config options, or data computed within the integration.\n *\n * @param {import(\"astro\").HookParameters<\"astro:config:setup\">} params\n * @param {object} options\n * @param {string} options.name\n * @param {Imports} options.imports\n *\n * @see https://astro-integration-kit.netlify.app/utilities/add-virtual-imports/\n *\n * @example\n * ```ts\n * // my-integration/index.ts\n * import { addVirtualImports } from \"astro-integration-kit\";\n *\n * addVirtualImports(params, {\n * \t\tname: 'my-integration',\n * \t\timports: {\n * \t\t\t'virtual:my-integration/config': `export default ${ JSON.stringify({foo: \"bar\"}) }`,\n * \t\t},\n *\t});\n * ```\n *\n * This is then readable anywhere else in your integration:\n *\n * ```ts\n * // myIntegration/src/component/layout.astro\n * import config from \"virtual:my-integration/config\";\n *\n * console.log(config.foo) // \"bar\"\n * ```\n */\nexport const addVirtualImports = defineUtility(\"astro:config:setup\")(\n\t(\n\t\tparams,\n\t\t{\n\t\t\tname,\n\t\t\timports,\n\t\t\t__enableCorePowerDoNotUseOrYouWillBeFired = false,\n\t\t}: {\n\t\t\tname: string;\n\t\t\timports: Imports;\n\t\t\t__enableCorePowerDoNotUseOrYouWillBeFired?: boolean;\n\t\t},\n\t) => {\n\t\tlet pluginName = `vite-plugin-${name}`;\n\n\t\twhile (hasVitePlugin(params, { plugin: pluginName }))\n\t\t\tpluginName = incrementPluginName(pluginName);\n\n\t\taddVitePlugin(params, {\n\t\t\twarnDuplicated: false,\n\t\t\tplugin: createVirtualModule(\n\t\t\t\tpluginName,\n\t\t\t\timports,\n\t\t\t\t__enableCorePowerDoNotUseOrYouWillBeFired,\n\t\t\t),\n\t\t});\n\t},\n);\n","import type { HookParameters, Hooks } from \"./types.js\";\n\n/**\n * Allows defining a type-safe function requiring all the params of a given hook.\n * It uses currying to make TypeScript happy.\n *\n * @param {string} _hook\n *\n * @see https://astro-integration-kit.netlify.app/utilities/define-utility/\n *\n * @example\n * ```ts\n * const test = defineUtility(\"astro:config:setup\")((params, foo: boolean) => {\n *  return \"bar\";\n * });\n * ```\n */\nexport const defineUtility =\n\t<THook extends keyof Hooks>(_hook: THook) =>\n\t/**\n\t * The function itself\n\t * @param {Function} fn;\n\t */\n\t<TFn extends (params: HookParameters<THook>, ...args: Array<any>) => any>(\n\t\tfn: TFn,\n\t) =>\n\t\tfn;\n","import type { AstroConfig } from \"astro\";\nimport type { PluginOption } from \"vite\";\nimport { defineUtility } from \"../core/define-utility.js\";\n\nfunction getPluginNames(plugins: AstroConfig[\"vite\"][\"plugins\"]) {\n\tconst names: string[] = [];\n\n\tif (plugins) {\n\t\tfor (const plugin of plugins) {\n\t\t\tif (!plugin) continue;\n\n\t\t\tif (Array.isArray(plugin)) {\n\t\t\t\tnames.push(...getPluginNames(plugin));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (plugin instanceof Promise) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnames.push(plugin.name);\n\t\t}\n\t}\n\n\treturn names;\n}\n\n/**\n * Checks for the existence of a Vite plugin inside the Astro config.\n *\n * @param {import(\"astro\").HookParameters<\"astro:config:setup\">} params\n * @param {Params} options\n * @param {string | import(\"vite\").PluginOption} options.plugin\n *\n * @see https://astro-integration-kit.netlify.app/utilities/has-vite-plugin/\n *\n * @example\n * ```ts\n * hasVitePlugin(params, {\n * \t\tplugin: \"vite-plugin-my-integration\",\n * })\n * ```\n */\nexport const hasVitePlugin = defineUtility(\"astro:config:setup\")(\n\t(\n\t\t{ config },\n\t\t{\n\t\t\tplugin,\n\t\t}: {\n\t\t\tplugin: string | PluginOption;\n\t\t},\n\t): boolean => {\n\t\tif (!plugin || plugin instanceof Promise) return false;\n\n\t\tconst currentPlugins = new Set(getPluginNames(config?.vite?.plugins));\n\n\t\tconst plugins = new Set<string>();\n\n\t\tif (typeof plugin === \"string\") {\n\t\t\tplugins.add(plugin);\n\t\t}\n\n\t\tif (typeof plugin === \"object\") {\n\t\t\tif (Array.isArray(plugin)) {\n\t\t\t\tconst names = new Set(\n\t\t\t\t\tgetPluginNames(plugin as NonNullable<AstroConfig[\"vite\"][\"plugins\"]>),\n\t\t\t\t);\n\t\t\t\tfor (const name of names) plugins.add(name);\n\t\t\t} else {\n\t\t\t\tplugins.add(plugin.name);\n\t\t\t}\n\t\t}\n\n\t\treturn [...plugins].some((name) => currentPlugins.has(name));\n\t},\n);\n","import type { Plugin, PluginOption } from \"vite\";\nimport { defineUtility } from \"../core/define-utility.js\";\nimport { hasVitePlugin } from \"./has-vite-plugin.js\";\n\n/**\n * Adds a [vite plugin](https://vitejs.dev/guide/using-plugins) to the\n * Astro config.\n *\n * @param {import(\"astro\").HookParameters<\"astro:config:setup\">} params\n * @param {object} options\n * @param {import(\"vite\").PluginOption} options.plugin\n * @param {boolean} [options.warnDuplicated=true]\n *\n * @see https://astro-integration-kit.netlify.app/utilities/add-vite-plugin/\n *\n * @example\n * ```ts\n * addVitePlugin(params, {\n * \t\tplugin,\n * \t\twarnDuplicated: true,\n * })\n * ```\n */\nexport const addVitePlugin = defineUtility(\"astro:config:setup\")(\n\t(\n\t\tparams,\n\t\t{\n\t\t\tplugin,\n\t\t\twarnDuplicated = true,\n\t\t}: {\n\t\t\tplugin: PluginOption;\n\t\t\twarnDuplicated?: boolean;\n\t\t},\n\t) => {\n\t\tconst { updateConfig, logger } = params;\n\n\t\tif (warnDuplicated && hasVitePlugin(params, { plugin })) {\n\t\t\tlogger.warn(\n\t\t\t\t`The Vite plugin \"${\n\t\t\t\t\t(plugin as Plugin).name\n\t\t\t\t}\" is already present in your Vite configuration, this plugin may not behave correctly.`,\n\t\t\t);\n\t\t}\n\n\t\tupdateConfig({\n\t\t\tvite: {\n\t\t\t\tplugins: [plugin],\n\t\t\t},\n\t\t});\n\t},\n);\n"],"mappings":"AAAA,OAAS,cAAAA,MAAkB,eCiBpB,IAAMC,EACgBC,GAM3BC,GAEAA,ECtBF,SAASC,EAAeC,EAAyC,CAChE,IAAMC,EAAkB,CAAC,EAEzB,GAAID,GACH,QAAWE,KAAUF,EACpB,GAAKE,EAEL,IAAI,MAAM,QAAQA,CAAM,EAAG,CAC1BD,EAAM,KAAK,GAAGF,EAAeG,CAAM,CAAC,EACpC,QACD,CAEIA,aAAkB,SAItBD,EAAM,KAAKC,EAAO,IAAI,GAIxB,OAAOD,CACR,CAkBO,IAAME,EAAgBC,EAAc,oBAAoB,EAC9D,CACC,CAAE,OAAAC,CAAO,EACT,CACC,OAAAH,CACD,IAGa,CACb,GAAI,CAACA,GAAUA,aAAkB,QAAS,MAAO,GAEjD,IAAMI,EAAiB,IAAI,IAAIP,EAAeM,GAAQ,MAAM,OAAO,CAAC,EAE9DL,EAAU,IAAI,IAMpB,GAJI,OAAOE,GAAW,UACrBF,EAAQ,IAAIE,CAAM,EAGf,OAAOA,GAAW,SACrB,GAAI,MAAM,QAAQA,CAAM,EAAG,CAC1B,IAAMD,EAAQ,IAAI,IACjBF,EAAeG,CAAqD,CACrE,EACA,QAAWK,KAAQN,EAAOD,EAAQ,IAAIO,CAAI,CAC3C,MACCP,EAAQ,IAAIE,EAAO,IAAI,EAIzB,MAAO,CAAC,GAAGF,CAAO,EAAE,KAAMO,GAASD,EAAe,IAAIC,CAAI,CAAC,CAC5D,CACD,ECpDO,IAAMC,EAAgBC,EAAc,oBAAoB,EAC9D,CACCC,EACA,CACC,OAAAC,EACA,eAAAC,EAAiB,EAClB,IAII,CACJ,GAAM,CAAE,aAAAC,EAAc,OAAAC,CAAO,EAAIJ,EAE7BE,GAAkBG,EAAcL,EAAQ,CAAE,OAAAC,CAAO,CAAC,GACrDG,EAAO,KACN,oBACEH,EAAkB,IACpB,wFACD,EAGDE,EAAa,CACZ,KAAM,CACL,QAAS,CAACF,CAAM,CACjB,CACD,CAAC,CACF,CACD,EHpCA,IAAMK,EAAuBC,GAAiB,CAC7C,IAAIC,EAAQ,EACZ,MAAO,GAAGD,EAAK,QAAQ,UAAW,CAACE,EAAGC,KACrCF,EAAQ,SAASE,CAAC,EAAI,EACf,GACP,CAAC,IAAIF,CAAK,EACZ,EAEMG,EAA4CC,GAC1C,KAAKA,CAAE,GAGTC,EAAsB,CAC3BN,EACAO,EACAC,IACY,CAEZ,IAAMC,EAAgC,MAAM,QAAQF,CAAQ,EACzDA,EACA,OAAO,QAAQA,CAAQ,EAAE,IAAI,CAAC,CAACF,EAAIK,CAAO,KAAO,CACjD,GAAAL,EACA,QAAAK,EACA,QAAS,MACT,EAAE,EAICC,EAAmD,CAAC,EAC1D,OAAW,CAAE,GAAAN,EAAI,QAAAO,CAAQ,IAAKH,EAC7BE,EAAkBN,CAAE,IAAM,CAAC,EAC3BM,EAAkBN,CAAE,GAAG,KACtB,GAAIO,IAAY,OAAY,CAAC,SAAU,QAAQ,EAAI,CAACA,CAAO,CAC5D,EAED,OAAW,CAACP,EAAIQ,CAAQ,IAAK,OAAO,QAAQF,CAAiB,EAC5D,GAAIE,EAAS,SAAW,CAAC,GAAG,IAAI,IAAIA,CAAQ,CAAC,EAAE,OAC9C,MAAM,IAAIC,EACT,2BAA2BT,CAAE,gEAC9B,EAIF,IAAMU,EAAgB,OAAO,YAC5BN,EAAQ,IAAI,CAAC,CAAE,GAAAJ,CAAG,IAAM,CACvB,GAAI,CAACG,GAAwBH,EAAG,WAAW,QAAQ,EAClD,MAAM,IAAIS,EACT,sDAAsDT,CAAE,0CACzD,EAGD,MAAO,CAACD,EAAuBC,CAAE,EAAGA,CAAE,CACvC,CAAC,CACF,EAEA,MAAO,CACN,KAAAL,EACA,UAAUK,EAAI,CACb,GAAII,EAAQ,KAAMO,GAAYA,EAAQ,KAAOX,CAAE,EAC9C,OAAOD,EAAuBC,CAAE,CAGlC,EACA,KAAKA,EAAIY,EAAS,CACjB,IAAMC,EAAaH,EAAcV,CAAE,EACnC,GAAIa,EAAY,CACf,IAAMN,EAAUK,GAAS,IAAM,SAAW,SACpCE,EAAOV,EAAQ,KACnBO,GACAA,EAAQ,KAAOE,IACdF,EAAQ,UAAY,QAAaA,EAAQ,UAAYJ,EACxD,EAEA,GAAIO,EACH,OAAOA,EAAK,OAEd,CAED,CACD,CACD,EAmCaC,EAAoBC,EAAc,oBAAoB,EAClE,CACCC,EACA,CACC,KAAAtB,EACA,QAAAS,EACA,0CAAAc,EAA4C,EAC7C,IAKI,CACJ,IAAIC,EAAa,eAAexB,CAAI,GAEpC,KAAOyB,EAAcH,EAAQ,CAAE,OAAQE,CAAW,CAAC,GAClDA,EAAazB,EAAoByB,CAAU,EAE5CE,EAAcJ,EAAQ,CACrB,eAAgB,GAChB,OAAQhB,EACPkB,EACAf,EACAc,CACD,CACD,CAAC,CACF,CACD","names":["AstroError","defineUtility","_hook","fn","getPluginNames","plugins","names","plugin","hasVitePlugin","defineUtility","config","currentPlugins","name","addVitePlugin","defineUtility","params","plugin","warnDuplicated","updateConfig","logger","hasVitePlugin","incrementPluginName","name","count","_","c","resolveVirtualModuleId","id","createVirtualModule","_imports","bypassCoreValidation","imports","content","duplicatedImports","context","contexts","AstroError","resolutionMap","_import","options","resolution","data","addVirtualImports","defineUtility","params","__enableCorePowerDoNotUseOrYouWillBeFired","pluginName","hasVitePlugin","addVitePlugin"]}