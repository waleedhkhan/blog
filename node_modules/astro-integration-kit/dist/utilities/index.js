import{mkdirSync as A,readFileSync as b,writeFileSync as h}from"node:fs";import{dirname as U,relative as V}from"node:path";import{fileURLToPath as p}from"node:url";import{parse as T,prettyPrint as $}from"recast";import k from"recast/parsers/typescript.js";var a=r=>t=>t;var D=({srcDir:r,logger:t,specifier:e})=>{let n=p(new URL("env.d.ts",r));e instanceof URL&&(e=p(e),e=V(p(r),e),e=e.replaceAll("\\","/"));let o=b(n,"utf8");if(o.includes(`/// <reference types='${e}' />`)||o.includes(`/// <reference types="${e}" />`))return;let s=o.replace("/// <reference types='astro/client' />",`/// <reference types='astro/client' />
/// <reference types='${e}' />`).replace('/// <reference types="astro/client" />',`/// <reference types="astro/client" />
/// <reference types="${e}" />`);s!==o&&(h(n,s),t.info("Updated env.d.ts types"))},R=a("astro:config:setup")(({config:{root:r,srcDir:t},logger:e},{name:n,content:o})=>{let s=new URL(`.astro/${n}.d.ts`,r),i=p(s);D({srcDir:t,logger:e,specifier:s}),A(U(i),{recursive:!0}),h(i,$(T(o,{parser:k}),{tabWidth:4}).code,"utf-8")});import{AstroError as v}from"astro/errors";function u(r){let t=[];if(r){for(let e of r)if(e){if(Array.isArray(e)){t.push(...u(e));continue}e instanceof Promise||t.push(e.name)}}return t}var c=a("astro:config:setup")(({config:r},{plugin:t})=>{if(!t||t instanceof Promise)return!1;let e=new Set(u(r?.vite?.plugins)),n=new Set;if(typeof t=="string"&&n.add(t),typeof t=="object")if(Array.isArray(t)){let o=new Set(u(t));for(let s of o)n.add(s)}else n.add(t.name);return[...n].some(o=>e.has(o))});var m=a("astro:config:setup")((r,{plugin:t,warnDuplicated:e=!0})=>{let{updateConfig:n,logger:o}=r;e&&c(r,{plugin:t})&&o.warn(`The Vite plugin "${t.name}" is already present in your Vite configuration, this plugin may not behave correctly.`),n({vite:{plugins:[t]}})});var S=r=>{let t=1;return`${r.replace(/-(\d+)$/,(e,n)=>(t=parseInt(n)+1,""))}-${t}`},P=r=>`\0${r}`,j=(r,t,e)=>{let n=Array.isArray(t)?t:Object.entries(t).map(([i,f])=>({id:i,content:f,context:void 0})),o={};for(let{id:i,context:f}of n)o[i]??=[],o[i]?.push(...f===void 0?["server","client"]:[f]);for(let[i,f]of Object.entries(o))if(f.length!==[...new Set(f)].length)throw new v(`Virtual import with id "${i}" has been registered several times with conflicting contexts.`);let s=Object.fromEntries(n.map(({id:i})=>{if(!e&&i.startsWith("astro:"))throw new v(`Virtual import name prefix can't be "astro:" (for "${i}") because it's reserved for Astro core.`);return[P(i),i]}));return{name:r,resolveId(i){if(n.find(f=>f.id===i))return P(i)},load(i,f){let g=s[i];if(g){let w=f?.ssr?"server":"client",y=n.find(l=>l.id===g&&(l.context===void 0||l.context===w));if(y)return y.content}}}},C=a("astro:config:setup")((r,{name:t,imports:e,__enableCorePowerDoNotUseOrYouWillBeFired:n=!1})=>{let o=`vite-plugin-${t}`;for(;c(r,{plugin:o});)o=S(o);m(r,{warnDuplicated:!1,plugin:j(o,e,n)})});import{AstroError as x}from"astro/errors";var d=a("astro:config:setup")(({config:r},{name:t,position:e,relativeTo:n})=>{let o=r.integrations.findIndex(i=>i.name===t);if(o===-1)return!1;if(e===void 0)return!0;if(n===void 0)throw new x("Cannot perform a relative integration check without a relative reference.","Pass `relativeTo` on your call to `hasIntegration` or remove the `position` option.");let s=r.integrations.findIndex(i=>i.name===n);if(s===-1)throw new x("Cannot check relative position against an absent integration.");return e==="before"?o<s:o>s});var H=a("astro:config:setup")(({command:r,injectRoute:t},e)=>{r==="dev"&&t(e)});import{readdirSync as L,statSync as F}from"node:fs";import{join as O,relative as N,resolve as E}from"pathe";var I=(r,t=r)=>{let e=L(r),n=[];for(let o of e){let s=O(r,o);if(F(s).isDirectory()){let f=I(s,t);n=n.concat(f)}else{let f=N(t,s);n.push(f)}}return n},W=a("astro:config:setup")(({addWatchFile:r,command:t,updateConfig:e},n)=>{if(t!=="dev")return;let o=I(n).map(s=>E(n,s));for(let s of o)r(s);e({vite:{plugins:[{name:`rollup-aik-watch-directory-${n}`,buildStart(){for(let s of o)this.addWatchFile(s)}}]}})});import"astro";var M=a("astro:config:setup")((r,{integration:t,ensureUnique:e})=>{let{logger:n,updateConfig:o}=r;if(e&&d(r,{name:t.name})){n.warn(`Integration "${t.name}" has already been added by the user or another integration. Skipping.`);return}o({integrations:[t]})});export{R as addDts,M as addIntegration,C as addVirtualImports,m as addVitePlugin,d as hasIntegration,c as hasVitePlugin,H as injectDevRoute,W as watchDirectory};
//# sourceMappingURL=index.js.map