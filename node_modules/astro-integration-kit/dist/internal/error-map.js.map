{"version":3,"sources":["../../src/internal/error-map.ts"],"sourcesContent":["import type { ZodErrorMap } from \"astro/zod\";\n\n// Source: https://github.com/withastro/astro/blob/d278e66ec6ded7a3ad441e6c3c5f9c265217936f/packages/astro/src/content/error-map.ts\n\ntype TypeOrLiteralErrByPathEntry = {\n\tcode: \"invalid_type\" | \"invalid_literal\";\n\treceived: unknown;\n\texpected: Array<unknown>;\n};\n\nexport const errorMap: ZodErrorMap = (baseError, ctx) => {\n\tconst baseErrorPath = flattenErrorPath(baseError.path);\n\tif (baseError.code === \"invalid_union\") {\n\t\t// Optimization: Combine type and literal errors for keys that are common across ALL union types\n\t\t// Ex. a union between `{ key: z.literal('tutorial') }` and `{ key: z.literal('blog') }` will\n\t\t// raise a single error when `key` does not match:\n\t\t// > Did not match union.\n\t\t// > key: Expected `'tutorial' | 'blog'`, received 'foo'\n\t\tconst typeOrLiteralErrByPath = new Map<\n\t\t\tstring,\n\t\t\tTypeOrLiteralErrByPathEntry\n\t\t>();\n\t\tfor (const unionError of baseError.unionErrors.flatMap((e) => e.errors)) {\n\t\t\tif (\n\t\t\t\tunionError.code === \"invalid_type\" ||\n\t\t\t\tunionError.code === \"invalid_literal\"\n\t\t\t) {\n\t\t\t\tconst flattenedErrorPath = flattenErrorPath(unionError.path);\n\t\t\t\tif (typeOrLiteralErrByPath.has(flattenedErrorPath)) {\n\t\t\t\t\ttypeOrLiteralErrByPath\n\t\t\t\t\t\t.get(flattenedErrorPath)!\n\t\t\t\t\t\t.expected.push(unionError.expected);\n\t\t\t\t} else {\n\t\t\t\t\ttypeOrLiteralErrByPath.set(flattenedErrorPath, {\n\t\t\t\t\t\tcode: unionError.code,\n\t\t\t\t\t\treceived: (unionError as any).received,\n\t\t\t\t\t\texpected: [unionError.expected],\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst messages: string[] = [\n\t\t\tprefix(\n\t\t\t\tbaseErrorPath,\n\t\t\t\ttypeOrLiteralErrByPath.size\n\t\t\t\t\t? \"Did not match union:\"\n\t\t\t\t\t: \"Did not match union.\",\n\t\t\t),\n\t\t];\n\t\treturn {\n\t\t\tmessage: messages\n\t\t\t\t.concat(\n\t\t\t\t\t[...typeOrLiteralErrByPath.entries()]\n\t\t\t\t\t\t// If type or literal error isn't common to ALL union types,\n\t\t\t\t\t\t// filter it out. Can lead to confusing noise.\n\t\t\t\t\t\t.filter(\n\t\t\t\t\t\t\t([, error]) =>\n\t\t\t\t\t\t\t\terror.expected.length === baseError.unionErrors.length,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.map(([key, error]) =>\n\t\t\t\t\t\t\tkey === baseErrorPath\n\t\t\t\t\t\t\t\t? // Avoid printing the key again if it's a base error\n\t\t\t\t\t\t\t\t  `> ${getTypeOrLiteralMsg(error)}`\n\t\t\t\t\t\t\t\t: `> ${prefix(key, getTypeOrLiteralMsg(error))}`,\n\t\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\t.join(\"\\n\"),\n\t\t};\n\t}\n\tif (\n\t\tbaseError.code === \"invalid_literal\" ||\n\t\tbaseError.code === \"invalid_type\"\n\t) {\n\t\treturn {\n\t\t\tmessage: prefix(\n\t\t\t\tbaseErrorPath,\n\t\t\t\tgetTypeOrLiteralMsg({\n\t\t\t\t\tcode: baseError.code,\n\t\t\t\t\treceived: (baseError as any).received,\n\t\t\t\t\texpected: [baseError.expected],\n\t\t\t\t}),\n\t\t\t),\n\t\t};\n\t} else if (baseError.message) {\n\t\treturn { message: prefix(baseErrorPath, baseError.message) };\n\t} else {\n\t\treturn { message: prefix(baseErrorPath, ctx.defaultError) };\n\t}\n};\n\nconst getTypeOrLiteralMsg = (error: TypeOrLiteralErrByPathEntry): string => {\n\tif (error.received === \"undefined\") return \"Required\";\n\tconst expectedDeduped = new Set(error.expected);\n\tswitch (error.code) {\n\t\tcase \"invalid_type\":\n\t\t\treturn `Expected type \\`${unionExpectedVals(\n\t\t\t\texpectedDeduped,\n\t\t\t)}\\`, received ${JSON.stringify(error.received)}`;\n\t\tcase \"invalid_literal\":\n\t\t\treturn `Expected \\`${unionExpectedVals(\n\t\t\t\texpectedDeduped,\n\t\t\t)}\\`, received ${JSON.stringify(error.received)}`;\n\t}\n};\n\nconst prefix = (key: string, msg: string) =>\n\tkey.length ? `**${key}**: ${msg}` : msg;\n\nconst unionExpectedVals = (expectedVals: Set<unknown>) =>\n\t[...expectedVals]\n\t\t.map((expectedVal, idx) => {\n\t\t\tif (idx === 0) return JSON.stringify(expectedVal);\n\t\t\tconst sep = \" | \";\n\t\t\treturn `${sep}${JSON.stringify(expectedVal)}`;\n\t\t})\n\t\t.join(\"\");\n\nconst flattenErrorPath = (errorPath: (string | number)[]) =>\n\terrorPath.join(\".\");\n"],"mappings":"AAUO,IAAMA,EAAwB,CAACC,EAAWC,IAAQ,CACxD,IAAMC,EAAgBC,EAAiBH,EAAU,IAAI,EACrD,GAAIA,EAAU,OAAS,gBAAiB,CAMvC,IAAMI,EAAyB,IAAI,IAInC,QAAWC,KAAcL,EAAU,YAAY,QAASM,GAAMA,EAAE,MAAM,EACrE,GACCD,EAAW,OAAS,gBACpBA,EAAW,OAAS,kBACnB,CACD,IAAME,EAAqBJ,EAAiBE,EAAW,IAAI,EACvDD,EAAuB,IAAIG,CAAkB,EAChDH,EACE,IAAIG,CAAkB,EACtB,SAAS,KAAKF,EAAW,QAAQ,EAEnCD,EAAuB,IAAIG,EAAoB,CAC9C,KAAMF,EAAW,KACjB,SAAWA,EAAmB,SAC9B,SAAU,CAACA,EAAW,QAAQ,CAC/B,CAAC,CAEH,CAUD,MAAO,CACN,QAT0B,CAC1BG,EACCN,EACAE,EAAuB,KACpB,uBACA,sBACJ,CACD,EAGG,OACA,CAAC,GAAGA,EAAuB,QAAQ,CAAC,EAGlC,OACA,CAAC,CAAC,CAAEK,CAAK,IACRA,EAAM,SAAS,SAAWT,EAAU,YAAY,MAClD,EACC,IAAI,CAAC,CAACU,EAAKD,CAAK,IAChBC,IAAQR,EAEL,KAAKS,EAAoBF,CAAK,CAAC,GAC/B,KAAKD,EAAOE,EAAKC,EAAoBF,CAAK,CAAC,CAAC,EAChD,CACF,EACC,KAAK;AAAA,CAAI,CACZ,CACD,CACA,OACCT,EAAU,OAAS,mBACnBA,EAAU,OAAS,eAEZ,CACN,QAASQ,EACRN,EACAS,EAAoB,CACnB,KAAMX,EAAU,KAChB,SAAWA,EAAkB,SAC7B,SAAU,CAACA,EAAU,QAAQ,CAC9B,CAAC,CACF,CACD,EACUA,EAAU,QACb,CAAE,QAASQ,EAAON,EAAeF,EAAU,OAAO,CAAE,EAEpD,CAAE,QAASQ,EAAON,EAAeD,EAAI,YAAY,CAAE,CAE5D,EAEMU,EAAuBF,GAA+C,CAC3E,GAAIA,EAAM,WAAa,YAAa,MAAO,WAC3C,IAAMG,EAAkB,IAAI,IAAIH,EAAM,QAAQ,EAC9C,OAAQA,EAAM,KAAM,CACnB,IAAK,eACJ,MAAO,mBAAmBI,EACzBD,CACD,CAAC,gBAAgB,KAAK,UAAUH,EAAM,QAAQ,CAAC,GAChD,IAAK,kBACJ,MAAO,cAAcI,EACpBD,CACD,CAAC,gBAAgB,KAAK,UAAUH,EAAM,QAAQ,CAAC,EACjD,CACD,EAEMD,EAAS,CAACE,EAAaI,IAC5BJ,EAAI,OAAS,KAAKA,CAAG,OAAOI,CAAG,GAAKA,EAE/BD,EAAqBE,GAC1B,CAAC,GAAGA,CAAY,EACd,IAAI,CAACC,EAAaC,IACdA,IAAQ,EAAU,KAAK,UAAUD,CAAW,EAEzC,MAAS,KAAK,UAAUA,CAAW,CAAC,EAC3C,EACA,KAAK,EAAE,EAEJb,EAAoBe,GACzBA,EAAU,KAAK,GAAG","names":["errorMap","baseError","ctx","baseErrorPath","flattenErrorPath","typeOrLiteralErrByPath","unionError","e","flattenedErrorPath","prefix","error","key","getTypeOrLiteralMsg","expectedDeduped","unionExpectedVals","msg","expectedVals","expectedVal","idx","errorPath"]}