{"version":3,"sources":["../../src/dev/hmr-integration.ts","../../src/core/define-integration.ts","../../src/internal/error-map.ts","../../src/utilities/watch-directory.ts","../../src/core/define-utility.ts"],"sourcesContent":["import { z } from \"astro/zod\";\nimport { defineIntegration } from \"../core/define-integration.js\";\nimport { watchDirectory } from \"../utilities/watch-directory.js\";\n\nexport const hmrIntegration = defineIntegration({\n\tname: \"astro-integration-kit/hmr\",\n\toptionsSchema: z.object({\n\t\tdirectory: z.string(),\n\t}),\n\tsetup({ options }) {\n\t\treturn {\n\t\t\thooks: {\n\t\t\t\t\"astro:config:setup\": (params) => {\n\t\t\t\t\twatchDirectory(params, options.directory);\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n});\n","import type { AstroIntegration } from \"astro\";\nimport { AstroError } from \"astro/errors\";\nimport { z } from \"astro/zod\";\nimport { errorMap } from \"../internal/error-map.js\";\n\ntype AstroIntegrationSetupFn<Options extends z.ZodTypeAny> = (params: {\n\tname: string;\n\toptions: z.output<Options>;\n}) => Omit<AstroIntegration, \"name\">;\n\n/**\n * A powerful wrapper around the standard Astro Integrations API. It allows integration authors to handle user options and global logic easily.\n *\n * @param {object} params\n * @param {string} params.name - The name of your integration\n * @param {import(\"astro/zod\").AnyZodObject} params.optionsSchema - An optional zod schema to handle your integration options\n * @param {function} params.setup - This will be called from your `astro:config:setup` call with the user options\n *\n * @see https://astro-integration-kit.netlify.app/utilities/define-integration/\n *\n * @example\n * ```ts\n * export default defineIntegration({\n * \t\tname: \"my-integration\",\n * \t\tsetup({ options }) {\n * \t\t\tconsole.log(options.foo); // \"bar\"\n * \t\t}\n * })\n * ```\n */\nexport const defineIntegration = <\n\tTOptionsSchema extends z.ZodTypeAny = z.ZodNever,\n\tTSetup extends\n\t\tAstroIntegrationSetupFn<TOptionsSchema> = AstroIntegrationSetupFn<TOptionsSchema>,\n>({\n\tname,\n\toptionsSchema,\n\tsetup,\n}: {\n\tname: string;\n\toptionsSchema?: TOptionsSchema;\n\tsetup: TSetup;\n}): ((\n\t...args: [z.input<TOptionsSchema>] extends [never]\n\t\t? []\n\t\t: undefined extends z.input<TOptionsSchema>\n\t\t  ? [options?: z.input<TOptionsSchema>]\n\t\t  : [options: z.input<TOptionsSchema>]\n) => AstroIntegration & ReturnType<TSetup>) => {\n\treturn (...args): AstroIntegration & ReturnType<TSetup> => {\n\t\tconst parsedOptions = (optionsSchema ?? z.never().optional()).safeParse(\n\t\t\targs[0],\n\t\t\t{\n\t\t\t\terrorMap,\n\t\t\t},\n\t\t);\n\n\t\tif (!parsedOptions.success) {\n\t\t\tthrow new AstroError(\n\t\t\t\t`Invalid options passed to \"${name}\" integration\\n`,\n\t\t\t\tparsedOptions.error.issues.map((i) => i.message).join(\"\\n\"),\n\t\t\t);\n\t\t}\n\n\t\tconst options = parsedOptions.data as z.output<TOptionsSchema>;\n\n\t\tconst integration = setup({ name, options }) as ReturnType<TSetup>;\n\n\t\treturn {\n\t\t\tname,\n\t\t\t...integration,\n\t\t};\n\t};\n};\n","import type { ZodErrorMap } from \"astro/zod\";\n\n// Source: https://github.com/withastro/astro/blob/d278e66ec6ded7a3ad441e6c3c5f9c265217936f/packages/astro/src/content/error-map.ts\n\ntype TypeOrLiteralErrByPathEntry = {\n\tcode: \"invalid_type\" | \"invalid_literal\";\n\treceived: unknown;\n\texpected: Array<unknown>;\n};\n\nexport const errorMap: ZodErrorMap = (baseError, ctx) => {\n\tconst baseErrorPath = flattenErrorPath(baseError.path);\n\tif (baseError.code === \"invalid_union\") {\n\t\t// Optimization: Combine type and literal errors for keys that are common across ALL union types\n\t\t// Ex. a union between `{ key: z.literal('tutorial') }` and `{ key: z.literal('blog') }` will\n\t\t// raise a single error when `key` does not match:\n\t\t// > Did not match union.\n\t\t// > key: Expected `'tutorial' | 'blog'`, received 'foo'\n\t\tconst typeOrLiteralErrByPath = new Map<\n\t\t\tstring,\n\t\t\tTypeOrLiteralErrByPathEntry\n\t\t>();\n\t\tfor (const unionError of baseError.unionErrors.flatMap((e) => e.errors)) {\n\t\t\tif (\n\t\t\t\tunionError.code === \"invalid_type\" ||\n\t\t\t\tunionError.code === \"invalid_literal\"\n\t\t\t) {\n\t\t\t\tconst flattenedErrorPath = flattenErrorPath(unionError.path);\n\t\t\t\tif (typeOrLiteralErrByPath.has(flattenedErrorPath)) {\n\t\t\t\t\ttypeOrLiteralErrByPath\n\t\t\t\t\t\t.get(flattenedErrorPath)!\n\t\t\t\t\t\t.expected.push(unionError.expected);\n\t\t\t\t} else {\n\t\t\t\t\ttypeOrLiteralErrByPath.set(flattenedErrorPath, {\n\t\t\t\t\t\tcode: unionError.code,\n\t\t\t\t\t\treceived: (unionError as any).received,\n\t\t\t\t\t\texpected: [unionError.expected],\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst messages: string[] = [\n\t\t\tprefix(\n\t\t\t\tbaseErrorPath,\n\t\t\t\ttypeOrLiteralErrByPath.size\n\t\t\t\t\t? \"Did not match union:\"\n\t\t\t\t\t: \"Did not match union.\",\n\t\t\t),\n\t\t];\n\t\treturn {\n\t\t\tmessage: messages\n\t\t\t\t.concat(\n\t\t\t\t\t[...typeOrLiteralErrByPath.entries()]\n\t\t\t\t\t\t// If type or literal error isn't common to ALL union types,\n\t\t\t\t\t\t// filter it out. Can lead to confusing noise.\n\t\t\t\t\t\t.filter(\n\t\t\t\t\t\t\t([, error]) =>\n\t\t\t\t\t\t\t\terror.expected.length === baseError.unionErrors.length,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.map(([key, error]) =>\n\t\t\t\t\t\t\tkey === baseErrorPath\n\t\t\t\t\t\t\t\t? // Avoid printing the key again if it's a base error\n\t\t\t\t\t\t\t\t  `> ${getTypeOrLiteralMsg(error)}`\n\t\t\t\t\t\t\t\t: `> ${prefix(key, getTypeOrLiteralMsg(error))}`,\n\t\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\t.join(\"\\n\"),\n\t\t};\n\t}\n\tif (\n\t\tbaseError.code === \"invalid_literal\" ||\n\t\tbaseError.code === \"invalid_type\"\n\t) {\n\t\treturn {\n\t\t\tmessage: prefix(\n\t\t\t\tbaseErrorPath,\n\t\t\t\tgetTypeOrLiteralMsg({\n\t\t\t\t\tcode: baseError.code,\n\t\t\t\t\treceived: (baseError as any).received,\n\t\t\t\t\texpected: [baseError.expected],\n\t\t\t\t}),\n\t\t\t),\n\t\t};\n\t} else if (baseError.message) {\n\t\treturn { message: prefix(baseErrorPath, baseError.message) };\n\t} else {\n\t\treturn { message: prefix(baseErrorPath, ctx.defaultError) };\n\t}\n};\n\nconst getTypeOrLiteralMsg = (error: TypeOrLiteralErrByPathEntry): string => {\n\tif (error.received === \"undefined\") return \"Required\";\n\tconst expectedDeduped = new Set(error.expected);\n\tswitch (error.code) {\n\t\tcase \"invalid_type\":\n\t\t\treturn `Expected type \\`${unionExpectedVals(\n\t\t\t\texpectedDeduped,\n\t\t\t)}\\`, received ${JSON.stringify(error.received)}`;\n\t\tcase \"invalid_literal\":\n\t\t\treturn `Expected \\`${unionExpectedVals(\n\t\t\t\texpectedDeduped,\n\t\t\t)}\\`, received ${JSON.stringify(error.received)}`;\n\t}\n};\n\nconst prefix = (key: string, msg: string) =>\n\tkey.length ? `**${key}**: ${msg}` : msg;\n\nconst unionExpectedVals = (expectedVals: Set<unknown>) =>\n\t[...expectedVals]\n\t\t.map((expectedVal, idx) => {\n\t\t\tif (idx === 0) return JSON.stringify(expectedVal);\n\t\t\tconst sep = \" | \";\n\t\t\treturn `${sep}${JSON.stringify(expectedVal)}`;\n\t\t})\n\t\t.join(\"\");\n\nconst flattenErrorPath = (errorPath: (string | number)[]) =>\n\terrorPath.join(\".\");\n","import { readdirSync, statSync } from \"node:fs\";\nimport { join, relative, resolve } from \"pathe\";\nimport { defineUtility } from \"../core/define-utility.js\";\n\nconst getFilesRecursively = (dir: string, baseDir = dir) => {\n\tconst files = readdirSync(dir);\n\tlet filepaths: Array<string> = [];\n\n\tfor (const file of files) {\n\t\tconst filepath = join(dir, file);\n\t\tconst _stat = statSync(filepath);\n\n\t\tif (_stat.isDirectory()) {\n\t\t\t// Recursively get files from subdirectories\n\t\t\tconst subDirectoryFiles = getFilesRecursively(filepath, baseDir);\n\t\t\tfilepaths = filepaths.concat(subDirectoryFiles);\n\t\t} else {\n\t\t\t// Calculate relative path and add it to the array\n\t\t\tconst relativePath = relative(baseDir, filepath);\n\t\t\tfilepaths.push(relativePath);\n\t\t}\n\t}\n\n\treturn filepaths;\n};\n\n/**\n * In development, will reload the Astro dev server if any files within\n * the directory has changed.\n *\n * @param {import(\"astro\").HookParameters<\"astro:config:setup\">} params\n * @param {string} directory\n *\n * @see https://astro-integration-kit.netlify.app/utilities/watch-directory/\n *\n * @example\n * ```ts\n * watchDirectory(params, resolve())\n * ```\n */\nexport const watchDirectory = defineUtility(\"astro:config:setup\")(\n\t({ addWatchFile, command, updateConfig }, directory: string) => {\n\t\tif (command !== \"dev\") {\n\t\t\treturn;\n\t\t}\n\n\t\tconst paths = getFilesRecursively(directory).map((p) =>\n\t\t\tresolve(directory, p),\n\t\t);\n\n\t\tfor (const path of paths) {\n\t\t\taddWatchFile(path);\n\t\t}\n\n\t\tupdateConfig({\n\t\t\tvite: {\n\t\t\t\tplugins: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: `rollup-aik-watch-directory-${directory}`,\n\t\t\t\t\t\tbuildStart() {\n\t\t\t\t\t\t\tfor (const path of paths) {\n\t\t\t\t\t\t\t\tthis.addWatchFile(path);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t});\n\t},\n);\n","import type { HookParameters, Hooks } from \"./types.js\";\n\n/**\n * Allows defining a type-safe function requiring all the params of a given hook.\n * It uses currying to make TypeScript happy.\n *\n * @param {string} _hook\n *\n * @see https://astro-integration-kit.netlify.app/utilities/define-utility/\n *\n * @example\n * ```ts\n * const test = defineUtility(\"astro:config:setup\")((params, foo: boolean) => {\n *  return \"bar\";\n * });\n * ```\n */\nexport const defineUtility =\n\t<THook extends keyof Hooks>(_hook: THook) =>\n\t/**\n\t * The function itself\n\t * @param {Function} fn;\n\t */\n\t<TFn extends (params: HookParameters<THook>, ...args: Array<any>) => any>(\n\t\tfn: TFn,\n\t) =>\n\t\tfn;\n"],"mappings":"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","names":["z","AstroError","z","errorMap","baseError","ctx","baseErrorPath","flattenErrorPath","typeOrLiteralErrByPath","unionError","e","flattenedErrorPath","prefix","error","key","getTypeOrLiteralMsg","expectedDeduped","unionExpectedVals","msg","expectedVals","expectedVal","idx","errorPath","defineIntegration","name","optionsSchema","setup","args","parsedOptions","z","errorMap","AstroError","i","options","integration","readdirSync","statSync","join","relative","resolve","defineUtility","_hook","fn","getFilesRecursively","dir","baseDir","files","readdirSync","filepaths","file","filepath","join","statSync","subDirectoryFiles","relativePath","relative","watchDirectory","defineUtility","addWatchFile","command","updateConfig","directory","paths","p","resolve","path","hmrIntegration","defineIntegration","z","options","params","watchDirectory"]}