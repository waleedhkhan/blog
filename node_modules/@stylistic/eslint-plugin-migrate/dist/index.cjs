'use strict';

const metadata = require('@eslint-stylistic/metadata');
const utils = require('@typescript-eslint/utils');

const createEslintRule = utils.ESLintUtils.RuleCreator(
  (ruleName) => ruleName
);
function createRuleListener(context, sets) {
  let parentNode;
  function findRule(fromName) {
    for (const set of sets) {
      const {
        namespaceFrom,
        namespaceTo,
        rules
      } = set;
      const ruleName = namespaceFrom ? fromName?.startsWith(`${namespaceFrom}/`) ? fromName.slice(namespaceFrom.length + 1) : null : fromName;
      if (!ruleName)
        continue;
      const rule = rules.find((r) => r.name === ruleName);
      if (!rule)
        continue;
      const toName = namespaceTo ? `${namespaceTo}/${ruleName}` : ruleName;
      return {
        rule,
        fromName,
        toName
      };
    }
  }
  return {
    Property(node) {
      if ((node.key.type === "Identifier" && node.key.name === "rules" || node.key.type === "Literal" && node.key.value === "rules") && node.value.type === "ObjectExpression") {
        parentNode = node.value;
        return;
      }
      if (!parentNode || parentNode !== node.parent)
        return;
      const fromName = node.key.type === "Literal" ? node.key.value : node.key.type === "Identifier" ? node.key.name : null;
      if (!(typeof fromName === "string"))
        return;
      const match = findRule(fromName);
      if (!match)
        return;
      const { toName } = match;
      context.report({
        node: node.key,
        messageId: "migrate",
        data: {
          from: fromName,
          to: toName
        },
        fix: (fixer) => {
          if (node.key.type === "Literal")
            return fixer.replaceText(node.key, node.key.raw[0] + toName + node.key.raw[0]);
          else
            return fixer.replaceText(node.key, `'${toName}'`);
        }
      });
    },
    JSONProperty(node) {
      if (node.key.type === "JSONLiteral" && node.key.value === "rules" && node.value.type === "JSONObjectExpression") {
        parentNode = node.value;
        return;
      }
      if (!parentNode || parentNode !== node.parent)
        return;
      const fromName = node.key.value;
      const match = findRule(fromName);
      if (!match)
        return;
      const { toName } = match;
      context.report({
        node: node.key,
        messageId: "migrate",
        data: {
          from: fromName,
          to: toName
        },
        fix: (fixer) => {
          return fixer.replaceText(node.key, `"${toName}"`);
        }
      });
    }
  };
}

const ts$1 = metadata.packages.find((p) => p.shortId === "ts");
const js$2 = metadata.packages.find((p) => p.shortId === "js");
const jsx = metadata.packages.find((p) => p.shortId === "jsx");
const migrate = createEslintRule({
  name: "migrate",
  meta: {
    type: "suggestion",
    docs: {
      description: "Migrate builtin and `@typescript-eslint` stylistic rules to `@stylistic` rules"
    },
    fixable: "code",
    messages: {
      migrate: "Should migrate stylistic rule '{{from}}' to '{{to}}'"
    },
    schema: [
      {
        type: "object",
        properties: {
          namespaceTo: {
            type: "string"
          }
        },
        additionalProperties: false
      }
    ]
  },
  defaultOptions: [{
    namespaceTo: "@stylistic"
  }],
  create(context, options) {
    return createRuleListener(
      context,
      [
        {
          namespaceFrom: "",
          namespaceTo: options[0].namespaceTo,
          rules: js$2.rules
        },
        {
          namespaceFrom: "@typescript-eslint",
          namespaceTo: options[0].namespaceTo,
          rules: ts$1.rules
        },
        {
          namespaceFrom: "react",
          namespaceTo: options[0].namespaceTo,
          rules: jsx.rules
        }
      ]
    );
  }
});

const js$1 = metadata.packages.find((p) => p.shortId === "js");
const migrateJs = createEslintRule({
  name: "migrate-js",
  meta: {
    type: "suggestion",
    docs: {
      description: "Migrate built-in stylistic rules to @stylistic/js rules"
    },
    fixable: "code",
    messages: {
      migrate: "Should migrate stylistic rule '{{from}}' to '{{to}}'"
    },
    schema: [
      {
        type: "object",
        properties: {
          namespaceTo: {
            type: "string"
          },
          namespaceFrom: {
            type: "string"
          }
        },
        additionalProperties: false
      }
    ]
  },
  defaultOptions: [{
    namespaceFrom: "",
    namespaceTo: "@stylistic/js"
  }],
  create(context, options) {
    return createRuleListener(
      context,
      [{
        namespaceFrom: options[0].namespaceFrom,
        namespaceTo: options[0].namespaceTo,
        rules: js$1.rules
      }]
    );
  }
});

const js = metadata.packages.find((p) => p.shortId === "jsx");
const migrateJsx = createEslintRule({
  name: "migrate-jsx",
  meta: {
    type: "suggestion",
    docs: {
      description: "Migrate JSX stylistic rules from `eslint-plugin-react` to @stylistic/jsx rules"
    },
    fixable: "code",
    messages: {
      migrate: "Should migrate stylistic rule '{{from}}' to '{{to}}'"
    },
    schema: [
      {
        type: "object",
        properties: {
          namespaceTo: {
            type: "string"
          },
          namespaceFrom: {
            type: "string"
          }
        },
        additionalProperties: false
      }
    ]
  },
  defaultOptions: [{
    namespaceFrom: "react",
    namespaceTo: "@stylistic/jsx"
  }],
  create(context, options) {
    return createRuleListener(
      context,
      [{
        namespaceFrom: options[0].namespaceFrom,
        namespaceTo: options[0].namespaceTo,
        rules: js.rules
      }]
    );
  }
});

const ts = metadata.packages.find((p) => p.shortId === "ts");
const migrateTs = createEslintRule({
  name: "migrate-ts",
  meta: {
    type: "suggestion",
    docs: {
      description: "Migrate `@typescript-eslint` stylistic rules to `@stylistic/ts` rules"
    },
    fixable: "code",
    messages: {
      migrate: "Should migrate stylistic rule '{{from}}' to '{{to}}'"
    },
    schema: [
      {
        type: "object",
        properties: {
          namespaceTo: {
            type: "string"
          },
          namespaceFrom: {
            type: "string"
          }
        },
        additionalProperties: false
      }
    ]
  },
  defaultOptions: [{
    namespaceFrom: "@typescript-eslint",
    namespaceTo: "@stylistic/ts"
  }],
  create(context, options) {
    return createRuleListener(
      context,
      [{
        namespaceFrom: options[0].namespaceFrom,
        namespaceTo: options[0].namespaceTo,
        rules: ts.rules
      }]
    );
  }
});

const index = {
  rules: {
    migrate,
    "migrate-ts": migrateTs,
    "migrate-js": migrateJs,
    "migrate-jsx": migrateJsx
  }
};

module.exports = index;
