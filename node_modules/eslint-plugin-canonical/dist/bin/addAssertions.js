"use strict";
/**
 * @file This script is used to inline assertions into the README.md documents.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const glob_1 = __importDefault(require("glob"));
const lodash_1 = __importDefault(require("lodash"));
const BASE_DIR = node_path_1.default.resolve(__dirname, '../..');
const formatCodeSnippet = (setup) => {
    const paragraphs = [];
    if (setup.options) {
        paragraphs.push('// Options: ' + JSON.stringify(setup.options).replaceAll(BASE_DIR, '<baseDir>'));
    }
    if (setup.settings) {
        paragraphs.push('// Settings: ' + JSON.stringify(setup.settings).replaceAll(BASE_DIR, '<baseDir>'));
    }
    paragraphs.push(setup.code);
    if (setup.errors) {
        for (const message of setup.errors) {
            paragraphs.push('// Message: ' + message.message);
        }
    }
    if (setup.rules) {
        paragraphs.push('// Additional rules: ' + JSON.stringify(setup.rules));
    }
    return paragraphs.join('\n');
};
const getAssertions = () => {
    const assertionFiles = glob_1.default.sync(node_path_1.default.resolve(__dirname, '../../tests/rules/*.ts'));
    const assertionNames = lodash_1.default.map(assertionFiles, (filePath) => {
        return node_path_1.default.basename(filePath, '.ts');
    });
    const assertionCodes = lodash_1.default.map(assertionFiles, (filePath) => {
        // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
        const codes = require(filePath);
        return {
            invalid: lodash_1.default.map(codes.default.testCases.invalid, formatCodeSnippet),
            valid: lodash_1.default.map(codes.default.testCases.valid, formatCodeSnippet),
        };
    });
    return lodash_1.default.zipObject(assertionNames, assertionCodes);
};
const updateDocuments = (assertions) => {
    const readmeDocumentPath = node_path_1.default.join(__dirname, '../../README.md');
    let documentBody;
    // eslint-disable-next-line node/no-sync
    documentBody = node_fs_1.default.readFileSync(readmeDocumentPath, 'utf8');
    documentBody = documentBody.replaceAll(/<!-- assertions ([a-z]+?) -->/giu, (assertionsBlock) => {
        let exampleBody;
        const ruleName = assertionsBlock.match(/assertions ([a-z]+)/iu)[1];
        const ruleAssertions = assertions[ruleName];
        if (!ruleAssertions) {
            throw new Error('No assertions available for rule "' + ruleName + '".');
        }
        exampleBody = '';
        if (ruleAssertions.invalid.length) {
            exampleBody +=
                'The following patterns are considered problems:\n\n```js\n' +
                    ruleAssertions.invalid.join('\n\n') +
                    '\n```\n\n';
        }
        if (ruleAssertions.valid.length) {
            exampleBody +=
                'The following patterns are not considered problems:\n\n```js\n' +
                    ruleAssertions.valid.join('\n\n') +
                    '\n```\n\n';
        }
        return `<details><summary>ðŸ“– Examples</summary>\n${exampleBody}</details>\n`;
    });
    // eslint-disable-next-line node/no-sync
    node_fs_1.default.writeFileSync(readmeDocumentPath, documentBody);
};
updateDocuments(getAssertions());
