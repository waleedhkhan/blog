"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/core.ts
var core_exports = {};
__export(core_exports, {
  DEFAULT_RESOLUTIONS: () => DEFAULT_RESOLUTIONS,
  getBreakpoints: () => getBreakpoints,
  getSizes: () => getSizes,
  getSrcSet: () => getSrcSet,
  getSrcSetEntries: () => getSrcSetEntries,
  getStyle: () => getStyle,
  inferImageDimensions: () => inferImageDimensions,
  logError: () => logError,
  normalizeImageType: () => normalizeImageType,
  transformProps: () => transformProps,
  transformSharedProps: () => transformSharedProps,
  transformSourceProps: () => transformSourceProps
});
module.exports = __toCommonJS(core_exports);
var import_unpic = require("unpic");

// src/mediaquery.ts
var RE_MEDIA_QUERY = /^(?:(only|not)?\s*([_a-z][_a-z0-9-]*)|(\([^)]+\)))(?:\s*and\s*(.*))?$/i;
var RE_MQ_EXPRESSION = /^\(\s*([_a-z-][_a-z0-9-]*)\s*(?::\s*([^)]+))?\s*\)$/;
var RE_MQ_FEATURE = /^(?:(min|max)-)?(.+)/;
function parse(mediaQuery) {
  return mediaQuery.split(",").map(function(query) {
    query = query.trim();
    const captures = query.match(RE_MEDIA_QUERY);
    if (!captures) {
      throw new SyntaxError('Invalid CSS media query: "' + query + '"');
    }
    const modifier = captures[1];
    const type = captures[2];
    const parsed = {
      inverse: !!modifier && modifier.toLowerCase() === "not",
      type: type ? type.toLowerCase() : "all",
      expressions: []
    };
    const expressions = ((captures[3] || "") + (captures[4] || "")).trim();
    if (!expressions) {
      return parsed;
    }
    const expressionList = expressions.match(/\([^)]+\)/g);
    if (!expressionList) {
      throw new SyntaxError('Invalid CSS media query: "' + query + '"');
    }
    parsed.expressions = expressionList.map(function(expression) {
      const captures2 = expression.match(RE_MQ_EXPRESSION);
      if (!captures2) {
        throw new SyntaxError('Invalid CSS media query: "' + query + '"');
      }
      const feature = captures2[1].toLowerCase().match(RE_MQ_FEATURE);
      return {
        modifier: feature?.[1] ?? "",
        feature: feature?.[2] ?? "",
        value: captures2[2]
      };
    });
    return parsed;
  });
}

// src/core.ts
var import_meta = {};
var DEBUG = import_meta.env?.DEV;
function logError(...args) {
  if (DEBUG) {
    console.error("[unpic]", ...args);
  }
}
var getSizes = (width, layout) => {
  if (!width || !layout) {
    return void 0;
  }
  switch (layout) {
    // If screen is wider than the max size, image width is the max size,
    // otherwise it's the width of the screen
    case `constrained`:
      return `(min-width: ${width}px) ${width}px, 100vw`;
    // Image is always the same width, whatever the size of the screen
    case `fixed`:
      return `${width}px`;
    // Image is always the width of the screen
    case `fullWidth`:
      return `100vw`;
    default:
      return void 0;
  }
};
var pixelate = (value) => value || value === 0 ? `${value}px` : void 0;
var getStyle = ({
  width,
  height,
  aspectRatio,
  layout,
  objectFit = "cover",
  background
}) => {
  const styleEntries = [
    ["object-fit", objectFit]
  ];
  if (background?.startsWith("https:") || background?.startsWith("http:") || background?.startsWith("data:") || background?.startsWith("/")) {
    styleEntries.push(["background-image", `url(${background})`]);
    styleEntries.push(["background-size", "cover"]);
    styleEntries.push(["background-repeat", "no-repeat"]);
  } else {
    styleEntries.push(["background", background]);
  }
  if (layout === "fixed") {
    styleEntries.push(["width", pixelate(width)]);
    styleEntries.push(["height", pixelate(height)]);
  }
  if (layout === "constrained") {
    styleEntries.push(["max-width", pixelate(width)]);
    styleEntries.push(["max-height", pixelate(height)]);
    styleEntries.push([
      "aspect-ratio",
      aspectRatio ? `${aspectRatio}` : void 0
    ]);
    styleEntries.push(["width", "100%"]);
  }
  if (layout === "fullWidth") {
    styleEntries.push(["width", "100%"]);
    styleEntries.push([
      "aspect-ratio",
      aspectRatio ? `${aspectRatio}` : void 0
    ]);
    styleEntries.push(["height", pixelate(height)]);
  }
  return Object.fromEntries(
    styleEntries.filter(([, value]) => value)
  );
};
var DEFAULT_RESOLUTIONS = [
  6016,
  // 6K
  5120,
  // 5K
  4480,
  // 4.5K
  3840,
  // 4K
  3200,
  // QHD+
  2560,
  // WQXGA
  2048,
  // QXGA
  1920,
  // 1080p
  1668,
  // Various iPads
  1280,
  // 720p
  1080,
  // iPhone 6-8 Plus
  960,
  // older horizontal phones
  828,
  // iPhone XR/11
  750,
  // iPhone 6-8
  640
  // older and lower-end phones
];
var LOW_RES_WIDTH = 24;
var getBreakpoints = ({
  width,
  layout,
  resolutions = DEFAULT_RESOLUTIONS
}) => {
  if (layout === "fullWidth") {
    return resolutions;
  }
  if (!width) {
    return [];
  }
  const doubleWidth = width * 2;
  if (layout === "fixed") {
    return [width, doubleWidth];
  }
  if (layout === "constrained") {
    return [
      // Always include the image at 1x and 2x the specified width
      width,
      doubleWidth,
      // Filter out any resolutions that are larger than the double-res image
      ...resolutions.filter((w) => w < doubleWidth)
    ];
  }
  return [];
};
var getSrcSetEntries = ({
  src,
  width,
  layout = "constrained",
  height,
  aspectRatio,
  breakpoints,
  cdn,
  transformer,
  format,
  cdnOptions
}) => {
  const canonical = (0, import_unpic.getCanonicalCdnForUrl)(src, cdn);
  if (canonical && !transformer) {
    transformer = (0, import_unpic.getTransformer)(canonical.cdn);
  }
  if (!transformer) {
    return [];
  }
  breakpoints ||= getBreakpoints({ width, layout });
  return breakpoints.sort((a, b) => a - b).map((bp) => {
    let transformedHeight;
    if (height && aspectRatio) {
      transformedHeight = Math.round(bp / aspectRatio);
    }
    return {
      url: canonical ? canonical.url : src,
      width: bp,
      height: transformedHeight,
      format,
      cdnOptions
    };
  });
};
var getSrcSet = (options) => {
  let { src, cdn, transformer } = options;
  const canonical = (0, import_unpic.getCanonicalCdnForUrl)(src, cdn);
  if (canonical && !transformer) {
    transformer = (0, import_unpic.getTransformer)(canonical.cdn);
  }
  if (!transformer) {
    return "";
  }
  return getSrcSetEntries({ ...options, transformer }).map((transform) => {
    const url = transformer(transform);
    return `${url?.toString()} ${transform.width}w`;
  }).join(",\n");
};
function transformSharedProps({
  width,
  height,
  priority,
  layout = "constrained",
  aspectRatio,
  ...props
}) {
  width = width && Number(width) || void 0;
  height = height && Number(height) || void 0;
  if (priority) {
    props.loading ||= "eager";
    props.fetchpriority ||= "high";
  } else {
    props.loading ||= "lazy";
    props.decoding ||= "async";
  }
  if (props.alt === "") {
    props.role ||= "presentation";
  }
  if (aspectRatio) {
    if (width) {
      if (height) {
        logError("Ignoring aspectRatio because width and height are both set");
      } else {
        height = Math.round(width / aspectRatio);
      }
    } else if (height) {
      width = Math.round(height * aspectRatio);
    } else if (layout !== "fullWidth") {
      logError(
        "When aspectRatio is set, either width or height must also be set"
      );
    }
  } else if (width && height) {
    aspectRatio = width / height;
  } else if (layout !== "fullWidth") {
    logError("Either aspectRatio or both width and height must be set");
  }
  return {
    width,
    height,
    aspectRatio,
    layout,
    ...props
  };
}
function transformProps(props) {
  let {
    src,
    cdn,
    transformer,
    background,
    layout,
    objectFit,
    breakpoints,
    width,
    height,
    aspectRatio,
    unstyled,
    cdnOptions,
    ...transformedProps
  } = transformSharedProps(props);
  const canonical = src ? (0, import_unpic.getCanonicalCdnForUrl)(src, cdn) : void 0;
  let url = src;
  if (canonical) {
    url = canonical.url;
    transformer ||= (0, import_unpic.getTransformer)(canonical.cdn);
  }
  if (transformer && background === "auto") {
    const lowResHeight = aspectRatio ? Math.round(LOW_RES_WIDTH / aspectRatio) : void 0;
    const lowResImage = transformer({
      url,
      width: LOW_RES_WIDTH,
      height: lowResHeight,
      cdnOptions
    });
    if (lowResImage) {
      background = lowResImage.toString();
    }
  }
  const styleProps = {
    width,
    height,
    aspectRatio,
    layout,
    objectFit,
    background
  };
  transformedProps.sizes ||= getSizes(width, layout);
  if (!unstyled) {
    transformedProps.style = {
      ...getStyle(styleProps),
      ...transformedProps.style
    };
  }
  if (transformer) {
    transformedProps.srcset = getSrcSet({
      src: url,
      width,
      height,
      aspectRatio,
      layout,
      breakpoints,
      transformer,
      cdn,
      cdnOptions
    });
    const transformed = transformer({ url, width, height, cdnOptions });
    if (transformed) {
      url = transformed;
    }
    if (layout === "fullWidth" || layout === "constrained") {
      width = void 0;
      height = void 0;
    }
  }
  if (!url) {
    logError("No URL provided for image");
  }
  return {
    ...transformedProps,
    src: url?.toString(),
    width,
    height
  };
}
function normalizeImageType(type) {
  if (!type) {
    return {};
  }
  if (type.startsWith("image/")) {
    return {
      format: type.slice(6),
      mimeType: type
    };
  }
  return {
    format: type,
    mimeType: `image/${type === "jpg" ? "jpeg" : type}`
  };
}
function transformSourceProps({ media, type, ...props }) {
  let {
    src,
    cdn,
    transformer,
    layout,
    breakpoints,
    width,
    height,
    aspectRatio,
    sizes,
    loading,
    decoding,
    cdnOptions,
    ...rest
  } = transformSharedProps(props);
  const canonical = src ? (0, import_unpic.getCanonicalCdnForUrl)(src, cdn) : void 0;
  let url = src;
  if (canonical) {
    url = canonical.url;
    transformer ||= (0, import_unpic.getTransformer)(canonical.cdn);
  }
  if (!transformer) {
    return {};
  }
  const { format, mimeType } = normalizeImageType(type);
  sizes ||= getSizes(width, layout);
  const srcset = getSrcSet({
    src: url,
    width,
    height,
    aspectRatio,
    layout,
    breakpoints,
    transformer,
    cdn,
    format,
    cdnOptions
  });
  const transformed = transformer({ url, width, height, cdnOptions });
  if (transformed) {
    url = transformed;
  }
  const returnObject = {
    ...rest,
    sizes,
    srcset
  };
  if (media) {
    if (DEBUG) {
      try {
        parse(media);
        returnObject.media = media;
      } catch (e) {
        logError(e.message);
      }
    } else {
      returnObject.media = media;
    }
  }
  if (mimeType) {
    returnObject.type = mimeType;
  }
  return returnObject;
}
function inferImageDimensions(props, imageData) {
  const aspectRatio = props.aspectRatio || imageData.width / imageData.height;
  let { width, height } = props;
  if (!width) {
    if (height) {
      width = height * aspectRatio;
    } else {
      width = imageData.width;
    }
  }
  if (!height) {
    if (width) {
      height = width / aspectRatio;
    } else {
      height = imageData.height;
    }
  }
  return { width, height };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DEFAULT_RESOLUTIONS,
  getBreakpoints,
  getSizes,
  getSrcSet,
  getSrcSetEntries,
  getStyle,
  inferImageDimensions,
  logError,
  normalizeImageType,
  transformProps,
  transformSharedProps,
  transformSourceProps
});
